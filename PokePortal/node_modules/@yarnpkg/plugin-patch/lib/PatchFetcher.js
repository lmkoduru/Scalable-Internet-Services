"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PatchFetcher = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@yarnpkg/core");
const core_2 = require("@yarnpkg/core");
const fslib_1 = require("@yarnpkg/fslib");
const libzip_1 = require("@yarnpkg/libzip");
const patchUtils = tslib_1.__importStar(require("./patchUtils"));
const UnmatchedHunkError_1 = require("./tools/UnmatchedHunkError");
const format_1 = require("./tools/format");
class PatchFetcher {
    supports(locator, opts) {
        if (!patchUtils.isPatchLocator(locator))
            return false;
        return true;
    }
    getLocalPath(locator, opts) {
        return null;
    }
    async fetch(locator, opts) {
        const expectedChecksum = opts.checksums.get(locator.locatorHash) || null;
        const [packageFs, releaseFs, checksum] = await opts.cache.fetchPackageFromCache(locator, expectedChecksum, {
            onHit: () => opts.report.reportCacheHit(locator),
            onMiss: () => opts.report.reportCacheMiss(locator, `${core_2.structUtils.prettyLocator(opts.project.configuration, locator)} can't be found in the cache and will be fetched from the disk`),
            loader: () => this.patchPackage(locator, opts),
            ...opts.cacheOptions,
        });
        return {
            packageFs,
            releaseFs,
            prefixPath: core_2.structUtils.getIdentVendorPath(locator),
            localPath: this.getLocalPath(locator, opts),
            checksum,
        };
    }
    async patchPackage(locator, opts) {
        const { parentLocator, sourceLocator, sourceVersion, patchPaths } = patchUtils.parseLocator(locator);
        const patchFiles = await patchUtils.loadPatchFiles(parentLocator, patchPaths, opts);
        const tmpDir = await fslib_1.xfs.mktempPromise();
        const currentFile = fslib_1.ppath.join(tmpDir, `current.zip`);
        const sourceFetch = await opts.fetcher.fetch(sourceLocator, opts);
        const prefixPath = core_2.structUtils.getIdentVendorPath(locator);
        // First we create a copy of the package that we'll be free to mutate
        const initialCopy = new libzip_1.ZipFS(currentFile, {
            create: true,
            level: opts.project.configuration.get(`compressionLevel`),
        });
        await core_2.miscUtils.releaseAfterUseAsync(async () => {
            await initialCopy.copyPromise(prefixPath, sourceFetch.prefixPath, { baseFs: sourceFetch.packageFs, stableSort: true });
        }, sourceFetch.releaseFs);
        initialCopy.saveAndClose();
        for (const { source, optional } of patchFiles) {
            if (source === null)
                continue;
            // Then for each patchfile, we open this copy anew, and try to apply the
            // changeset. We need to open it for each patchfile (rather than only a
            // single time) because it lets us easily rollback when hitting errors
            // on optional patches (we just need to call `discardAndClose`).
            const patchedPackage = new libzip_1.ZipFS(currentFile, {
                level: opts.project.configuration.get(`compressionLevel`),
            });
            const patchFs = new fslib_1.CwdFS(fslib_1.ppath.resolve(fslib_1.PortablePath.root, prefixPath), {
                baseFs: patchedPackage,
            });
            try {
                await patchUtils.applyPatchFile(patchUtils.parsePatchFile(source), {
                    baseFs: patchFs,
                    version: sourceVersion,
                });
            }
            catch (err) {
                if (!(err instanceof UnmatchedHunkError_1.UnmatchedHunkError))
                    throw err;
                const enableInlineHunks = opts.project.configuration.get(`enableInlineHunks`);
                const suggestion = !enableInlineHunks && !optional
                    ? ` (set enableInlineHunks for details)`
                    : ``;
                const message = `${core_2.structUtils.prettyLocator(opts.project.configuration, locator)}: ${err.message}${suggestion}`;
                const reportExtra = (report) => {
                    if (!enableInlineHunks)
                        return;
                    (0, format_1.reportHunk)(err.hunk, {
                        configuration: opts.project.configuration,
                        report,
                    });
                };
                // By discarding the current changes, the next patch will start from
                // where we were.
                patchedPackage.discardAndClose();
                if (optional) {
                    opts.report.reportWarningOnce(core_1.MessageName.PATCH_HUNK_FAILED, message, { reportExtra });
                    continue;
                }
                else {
                    throw new core_1.ReportError(core_1.MessageName.PATCH_HUNK_FAILED, message, reportExtra);
                }
            }
            patchedPackage.saveAndClose();
        }
        return new libzip_1.ZipFS(currentFile, {
            level: opts.project.configuration.get(`compressionLevel`),
        });
    }
}
exports.PatchFetcher = PatchFetcher;
