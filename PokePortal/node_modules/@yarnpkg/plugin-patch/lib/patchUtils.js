"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.makePatchHash = exports.diffFolders = exports.extractPackageToDisk = exports.loadPatchFiles = exports.isParentRequired = exports.extractPatchFlags = exports.makeLocator = exports.makeDescriptor = exports.ensureUnpatchedLocator = exports.ensureUnpatchedDescriptor = exports.unpatchLocator = exports.unpatchDescriptor = exports.parseLocator = exports.parseDescriptor = exports.isPatchLocator = exports.isPatchDescriptor = exports.parsePatchFile = exports.applyPatchFile = void 0;
const core_1 = require("@yarnpkg/core");
const fslib_1 = require("@yarnpkg/fslib");
const constants_1 = require("./constants");
const parse_1 = require("./tools/parse");
Object.defineProperty(exports, "parsePatchFile", { enumerable: true, get: function () { return parse_1.parsePatchFile; } });
var apply_1 = require("./tools/apply");
Object.defineProperty(exports, "applyPatchFile", { enumerable: true, get: function () { return apply_1.applyPatchFile; } });
const BUILTIN_REGEXP = /^builtin<([^>]+)>$/;
function parseSpec(spec, sourceParser) {
    const { protocol, source, selector, params } = core_1.structUtils.parseRange(spec);
    if (protocol !== `patch:`)
        throw new Error(`Invalid patch range`);
    if (source === null)
        throw new Error(`Patch locators must explicitly define their source`);
    const patchPaths = selector
        ? selector.split(/&/).map(path => fslib_1.npath.toPortablePath(path))
        : [];
    const parentLocator = params && typeof params.locator === `string`
        ? core_1.structUtils.parseLocator(params.locator)
        : null;
    const sourceVersion = params && typeof params.version === `string`
        ? params.version
        : null;
    const sourceItem = sourceParser(source);
    return { parentLocator, sourceItem, patchPaths, sourceVersion };
}
function isPatchDescriptor(descriptor) {
    return descriptor.range.startsWith(`patch:`);
}
exports.isPatchDescriptor = isPatchDescriptor;
function isPatchLocator(locator) {
    return locator.reference.startsWith(`patch:`);
}
exports.isPatchLocator = isPatchLocator;
function parseDescriptor(descriptor) {
    const { sourceItem, ...rest } = parseSpec(descriptor.range, core_1.structUtils.parseDescriptor);
    return { ...rest, sourceDescriptor: sourceItem };
}
exports.parseDescriptor = parseDescriptor;
function parseLocator(locator) {
    const { sourceItem, ...rest } = parseSpec(locator.reference, core_1.structUtils.parseLocator);
    return { ...rest, sourceLocator: sourceItem };
}
exports.parseLocator = parseLocator;
function unpatchDescriptor(descriptor) {
    const { sourceItem } = parseSpec(descriptor.range, core_1.structUtils.parseDescriptor);
    return sourceItem;
}
exports.unpatchDescriptor = unpatchDescriptor;
function unpatchLocator(locator) {
    const { sourceItem } = parseSpec(locator.reference, core_1.structUtils.parseLocator);
    return sourceItem;
}
exports.unpatchLocator = unpatchLocator;
function ensureUnpatchedDescriptor(descriptor) {
    if (!isPatchDescriptor(descriptor))
        return descriptor;
    const { sourceItem } = parseSpec(descriptor.range, core_1.structUtils.parseDescriptor);
    return sourceItem;
}
exports.ensureUnpatchedDescriptor = ensureUnpatchedDescriptor;
function ensureUnpatchedLocator(locator) {
    if (!isPatchLocator(locator))
        return locator;
    const { sourceItem } = parseSpec(locator.reference, core_1.structUtils.parseLocator);
    return sourceItem;
}
exports.ensureUnpatchedLocator = ensureUnpatchedLocator;
function makeSpec({ parentLocator, sourceItem, patchPaths, sourceVersion, patchHash }, sourceStringifier) {
    const parentLocatorSpread = parentLocator !== null
        ? { locator: core_1.structUtils.stringifyLocator(parentLocator) }
        : {};
    const sourceVersionSpread = typeof sourceVersion !== `undefined`
        ? { version: sourceVersion }
        : {};
    const patchHashSpread = typeof patchHash !== `undefined`
        ? { hash: patchHash }
        : {};
    return core_1.structUtils.makeRange({
        protocol: `patch:`,
        source: sourceStringifier(sourceItem),
        selector: patchPaths.join(`&`),
        params: {
            ...sourceVersionSpread,
            ...patchHashSpread,
            ...parentLocatorSpread,
        },
    });
}
function makeDescriptor(ident, { parentLocator, sourceDescriptor, patchPaths }) {
    return core_1.structUtils.makeDescriptor(ident, makeSpec({ parentLocator, sourceItem: sourceDescriptor, patchPaths }, core_1.structUtils.stringifyDescriptor));
}
exports.makeDescriptor = makeDescriptor;
function makeLocator(ident, { parentLocator, sourcePackage, patchPaths, patchHash }) {
    return core_1.structUtils.makeLocator(ident, makeSpec({ parentLocator, sourceItem: sourcePackage, sourceVersion: sourcePackage.version, patchPaths, patchHash }, core_1.structUtils.stringifyLocator));
}
exports.makeLocator = makeLocator;
function visitPatchPath({ onAbsolute, onRelative, onProject, onBuiltin }, patchPath) {
    const flagIndex = patchPath.lastIndexOf(`!`);
    if (flagIndex !== -1)
        patchPath = patchPath.slice(flagIndex + 1);
    const builtinMatch = patchPath.match(BUILTIN_REGEXP);
    if (builtinMatch !== null)
        return onBuiltin(builtinMatch[1]);
    if (patchPath.startsWith(`~/`))
        return onProject(patchPath.slice(2));
    if (fslib_1.ppath.isAbsolute(patchPath)) {
        return onAbsolute(patchPath);
    }
    else {
        return onRelative(patchPath);
    }
}
function extractPatchFlags(patchPath) {
    const flagIndex = patchPath.lastIndexOf(`!`);
    const flags = flagIndex !== -1
        ? new Set(patchPath.slice(0, flagIndex).split(/!/))
        : new Set();
    const optional = flags.has(`optional`);
    return { optional };
}
exports.extractPatchFlags = extractPatchFlags;
function isParentRequired(patchPath) {
    return visitPatchPath({
        onAbsolute: () => false,
        onRelative: () => true,
        onProject: () => false,
        onBuiltin: () => false,
    }, patchPath);
}
exports.isParentRequired = isParentRequired;
async function loadPatchFiles(parentLocator, patchPaths, opts) {
    // When the patch files use absolute paths we can directly access them via
    // their location on the disk. Otherwise we must go through the package fs.
    const parentFetch = parentLocator !== null
        ? await opts.fetcher.fetch(parentLocator, opts)
        : null;
    // If the package fs publicized its "original location" (for example like
    // in the case of "file:" packages), we use it to derive the real location.
    const effectiveParentFetch = parentFetch && parentFetch.localPath
        ? { packageFs: new fslib_1.CwdFS(fslib_1.PortablePath.root), prefixPath: fslib_1.ppath.relative(fslib_1.PortablePath.root, parentFetch.localPath) }
        : parentFetch;
    // Discard the parent fs unless we really need it to access the files
    if (parentFetch && parentFetch !== effectiveParentFetch && parentFetch.releaseFs)
        parentFetch.releaseFs();
    // First we obtain the specification for all the patches that we'll have to
    // apply to the original package.
    const patchFiles = await core_1.miscUtils.releaseAfterUseAsync(async () => {
        return await Promise.all(patchPaths.map(async (patchPath) => {
            const flags = extractPatchFlags(patchPath);
            const source = await visitPatchPath({
                onAbsolute: async (patchPath) => {
                    return await fslib_1.xfs.readFilePromise(patchPath, `utf8`);
                },
                onRelative: async (patchPath) => {
                    if (effectiveParentFetch === null)
                        throw new Error(`Assertion failed: The parent locator should have been fetched`);
                    return await effectiveParentFetch.packageFs.readFilePromise(fslib_1.ppath.join(effectiveParentFetch.prefixPath, patchPath), `utf8`);
                },
                onProject: async (patchPath) => {
                    return await fslib_1.xfs.readFilePromise(fslib_1.ppath.join(opts.project.cwd, patchPath), `utf8`);
                },
                onBuiltin: async (name) => {
                    return await opts.project.configuration.firstHook((hooks) => {
                        return hooks.getBuiltinPatch;
                    }, opts.project, name);
                },
            }, patchPath);
            return { ...flags, source };
        }));
    });
    // Normalizes the line endings to prevent mismatches when cloning a
    // repository on Windows systems (the default settings for Git are to
    // convert newlines back and forth, which would mess with the checksum)
    for (const spec of patchFiles)
        if (typeof spec.source === `string`)
            spec.source = spec.source.replace(/\r\n?/g, `\n`);
    return patchFiles;
}
exports.loadPatchFiles = loadPatchFiles;
async function extractPackageToDisk(locator, { cache, project }) {
    const pkg = project.storedPackages.get(locator.locatorHash);
    if (typeof pkg === `undefined`)
        throw new Error(`Assertion failed: Expected the package to be registered`);
    const unpatchedLocator = ensureUnpatchedLocator(locator);
    const checksums = project.storedChecksums;
    const report = new core_1.ThrowReport();
    const temp = await fslib_1.xfs.mktempPromise();
    const sourcePath = fslib_1.ppath.join(temp, `source`);
    const userPath = fslib_1.ppath.join(temp, `user`);
    const metaPath = fslib_1.ppath.join(temp, `.yarn-patch.json`);
    const fetcher = project.configuration.makeFetcher();
    const cleanup = [];
    try {
        let sourceFetchResult;
        let userFetchResult;
        if (locator.locatorHash === unpatchedLocator.locatorHash) {
            const fetchResult = await fetcher.fetch(locator, { cache, project, fetcher, checksums, report });
            cleanup.push(() => fetchResult.releaseFs?.());
            sourceFetchResult = fetchResult;
            userFetchResult = fetchResult;
        }
        else {
            sourceFetchResult = await fetcher.fetch(locator, { cache, project, fetcher, checksums, report });
            cleanup.push(() => sourceFetchResult.releaseFs?.());
            userFetchResult = await fetcher.fetch(locator, { cache, project, fetcher, checksums, report });
            cleanup.push(() => userFetchResult.releaseFs?.());
        }
        await Promise.all([
            fslib_1.xfs.copyPromise(sourcePath, sourceFetchResult.prefixPath, {
                baseFs: sourceFetchResult.packageFs,
            }),
            fslib_1.xfs.copyPromise(userPath, userFetchResult.prefixPath, {
                baseFs: userFetchResult.packageFs,
            }),
            fslib_1.xfs.writeJsonPromise(metaPath, {
                locator: core_1.structUtils.stringifyLocator(locator),
                version: pkg.version,
            }),
        ]);
    }
    finally {
        for (const cleanupFn of cleanup) {
            cleanupFn();
        }
    }
    fslib_1.xfs.detachTemp(temp);
    return userPath;
}
exports.extractPackageToDisk = extractPackageToDisk;
async function diffFolders(folderA, folderB) {
    const folderAN = fslib_1.npath.fromPortablePath(folderA).replace(/\\/g, `/`);
    const folderBN = fslib_1.npath.fromPortablePath(folderB).replace(/\\/g, `/`);
    const { stdout, stderr } = await core_1.execUtils.execvp(`git`, [`-c`, `core.safecrlf=false`, `diff`, `--src-prefix=a/`, `--dst-prefix=b/`, `--ignore-cr-at-eol`, `--full-index`, `--no-index`, `--no-renames`, `--text`, folderAN, folderBN], {
        cwd: fslib_1.npath.toPortablePath(process.cwd()),
        env: {
            ...process.env,
            //#region Predictable output
            // These variables aim to ignore the global git config so we get predictable output
            // https://git-scm.com/docs/git#Documentation/git.txt-codeGITCONFIGNOSYSTEMcode
            GIT_CONFIG_NOSYSTEM: `1`,
            HOME: ``,
            XDG_CONFIG_HOME: ``,
            USERPROFILE: ``,
            //#endregion
        },
    });
    // we cannot rely on exit code, because --no-index implies --exit-code
    // i.e. git diff will exit with 1 if there were differences
    if (stderr.length > 0)
        throw new Error(`Unable to diff directories. Make sure you have a recent version of 'git' available in PATH.\nThe following error was reported by 'git':\n${stderr}`);
    const normalizePath = folderAN.startsWith(`/`)
        ? (p) => p.slice(1)
        : (p) => p;
    return stdout
        .replace(new RegExp(`(a|b)(${core_1.miscUtils.escapeRegExp(`/${normalizePath(folderAN)}/`)})`, `g`), `$1/`)
        .replace(new RegExp(`(a|b)${core_1.miscUtils.escapeRegExp(`/${normalizePath(folderBN)}/`)}`, `g`), `$1/`)
        .replace(new RegExp(core_1.miscUtils.escapeRegExp(`${folderAN}/`), `g`), ``)
        .replace(new RegExp(core_1.miscUtils.escapeRegExp(`${folderBN}/`), `g`), ``);
}
exports.diffFolders = diffFolders;
function makePatchHash(patchFiles, sourceVersion) {
    const parts = [];
    for (const { source } of patchFiles) {
        if (source === null)
            continue;
        const effects = (0, parse_1.parsePatchFile)(source);
        for (const effect of effects) {
            const { semverExclusivity, ...effectWithoutRange } = effect;
            if (semverExclusivity !== null &&
                sourceVersion !== null &&
                !core_1.semverUtils.satisfiesWithPrereleases(sourceVersion, semverExclusivity))
                continue;
            parts.push(JSON.stringify(effectWithoutRange));
        }
    }
    return core_1.hashUtils.makeHash(`${constants_1.CACHE_VERSION}`, ...parts).slice(0, 6);
}
exports.makePatchHash = makePatchHash;
