"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const cli_1 = require("@yarnpkg/cli");
const core_1 = require("@yarnpkg/core");
const fslib_1 = require("@yarnpkg/fslib");
const clipanion_1 = require("clipanion");
const patchUtils = tslib_1.__importStar(require("../patchUtils"));
// eslint-disable-next-line arca/no-default-export
class PatchCommand extends cli_1.BaseCommand {
    constructor() {
        super(...arguments);
        this.update = clipanion_1.Option.Boolean(`-u,--update`, false, {
            description: `Reapply local patches that already apply to this packages`,
        });
        this.json = clipanion_1.Option.Boolean(`--json`, false, {
            description: `Format the output as an NDJSON stream`,
        });
        this.package = clipanion_1.Option.String();
    }
    async execute() {
        const configuration = await core_1.Configuration.find(this.context.cwd, this.context.plugins);
        const { project, workspace } = await core_1.Project.find(configuration, this.context.cwd);
        const cache = await core_1.Cache.find(configuration);
        if (!workspace)
            throw new cli_1.WorkspaceRequiredError(project.cwd, this.context.cwd);
        await project.restoreInstallState();
        let locator = core_1.structUtils.parseLocator(this.package);
        if (locator.reference === `unknown`) {
            const candidateLocators = core_1.miscUtils.mapAndFilter([...project.storedPackages.values()], pkg => {
                if (pkg.identHash !== locator.identHash)
                    return core_1.miscUtils.mapAndFilter.skip;
                if (core_1.structUtils.isVirtualLocator(pkg))
                    return core_1.miscUtils.mapAndFilter.skip;
                if (patchUtils.isPatchLocator(pkg) !== this.update)
                    return core_1.miscUtils.mapAndFilter.skip;
                return pkg;
            });
            if (candidateLocators.length === 0)
                throw new clipanion_1.UsageError(`No package found in the project for the given locator`);
            if (candidateLocators.length > 1)
                throw new clipanion_1.UsageError(`Multiple candidate packages found; explicitly choose one of them (use \`yarn why <package>\` to get more information as to who depends on them):\n${candidateLocators.map(locator => `\n- ${core_1.structUtils.prettyLocator(configuration, locator)}`).join(``)}`);
            locator = candidateLocators[0];
        }
        if (!project.storedPackages.has(locator.locatorHash))
            throw new clipanion_1.UsageError(`No package found in the project for the given locator`);
        await core_1.StreamReport.start({
            configuration,
            json: this.json,
            stdout: this.context.stdout,
        }, async (report) => {
            const unpatchedLocator = patchUtils.ensureUnpatchedLocator(locator);
            const temp = await patchUtils.extractPackageToDisk(locator, { cache, project });
            report.reportJson({
                locator: core_1.structUtils.stringifyLocator(unpatchedLocator),
                path: fslib_1.npath.fromPortablePath(temp),
            });
            const updateString = this.update
                ? ` along with its current modifications`
                : ``;
            report.reportInfo(core_1.MessageName.UNNAMED, `Package ${core_1.structUtils.prettyLocator(configuration, unpatchedLocator)} got extracted with success${updateString}!`);
            report.reportInfo(core_1.MessageName.UNNAMED, `You can now edit the following folder: ${core_1.formatUtils.pretty(configuration, fslib_1.npath.fromPortablePath(temp), `magenta`)}`);
            report.reportInfo(core_1.MessageName.UNNAMED, `Once you are done run ${core_1.formatUtils.pretty(configuration, `yarn patch-commit -s ${process.platform === `win32` ? `"` : ``}${fslib_1.npath.fromPortablePath(temp)}${process.platform === `win32` ? `"` : ``}`, `cyan`)} and Yarn will store a patchfile based on your changes.`);
        });
    }
}
PatchCommand.paths = [
    [`patch`],
];
PatchCommand.usage = clipanion_1.Command.Usage({
    description: `prepare a package for patching`,
    details: `
      This command will cause a package to be extracted in a temporary directory intended to be editable at will.

      Once you're done with your changes, run \`yarn patch-commit -s path\` (with \`path\` being the temporary directory you received) to generate a patchfile and register it into your top-level manifest via the \`patch:\` protocol. Run \`yarn patch-commit -h\` for more details.

      Calling the command when you already have a patch won't import it by default (in other words, the default behavior is to reset existing patches). However, adding the \`-u,--update\` flag will import any current patch.
    `,
});
exports.default = PatchCommand;
