"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const cli_1 = require("@yarnpkg/cli");
const core_1 = require("@yarnpkg/core");
const fslib_1 = require("@yarnpkg/fslib");
const clipanion_1 = require("clipanion");
const patchUtils = tslib_1.__importStar(require("../patchUtils"));
// eslint-disable-next-line arca/no-default-export
class PatchCommitCommand extends cli_1.BaseCommand {
    constructor() {
        super(...arguments);
        this.save = clipanion_1.Option.Boolean(`-s,--save`, false, {
            description: `Add the patch to your resolution entries`,
        });
        this.patchFolder = clipanion_1.Option.String();
    }
    async execute() {
        const configuration = await core_1.Configuration.find(this.context.cwd, this.context.plugins);
        const { project, workspace } = await core_1.Project.find(configuration, this.context.cwd);
        if (!workspace)
            throw new cli_1.WorkspaceRequiredError(project.cwd, this.context.cwd);
        await project.restoreInstallState();
        const folderPath = fslib_1.ppath.resolve(this.context.cwd, fslib_1.npath.toPortablePath(this.patchFolder));
        const sourcePath = fslib_1.ppath.join(folderPath, `../source`);
        const metaPath = fslib_1.ppath.join(folderPath, `../.yarn-patch.json`);
        if (!fslib_1.xfs.existsSync(sourcePath))
            throw new clipanion_1.UsageError(`The argument folder didn't get created by 'yarn patch'`);
        const diff = await patchUtils.diffFolders(sourcePath, folderPath);
        const meta = await fslib_1.xfs.readJsonPromise(metaPath);
        const locator = core_1.structUtils.parseLocator(meta.locator, true);
        if (!project.storedPackages.has(locator.locatorHash))
            throw new clipanion_1.UsageError(`No package found in the project for the given locator`);
        if (!this.save) {
            this.context.stdout.write(diff);
            return;
        }
        const patchFolder = configuration.get(`patchFolder`);
        const patchPath = fslib_1.ppath.join(patchFolder, `${core_1.structUtils.slugifyLocator(locator)}.patch`);
        await fslib_1.xfs.mkdirPromise(patchFolder, { recursive: true });
        await fslib_1.xfs.writeFilePromise(patchPath, diff);
        const workspaceDependents = [];
        const transitiveDependencies = new Map();
        for (const pkg of project.storedPackages.values()) {
            if (core_1.structUtils.isVirtualLocator(pkg))
                continue;
            const descriptor = pkg.dependencies.get(locator.identHash);
            if (!descriptor)
                continue;
            const devirtualizedDescriptor = core_1.structUtils.ensureDevirtualizedDescriptor(descriptor);
            const unpatchedDescriptor = patchUtils.ensureUnpatchedDescriptor(devirtualizedDescriptor);
            const resolution = project.storedResolutions.get(unpatchedDescriptor.descriptorHash);
            if (!resolution)
                throw new Error(`Assertion failed: Expected the resolution to have been registered`);
            const dependency = project.storedPackages.get(resolution);
            if (!dependency)
                throw new Error(`Assertion failed: Expected the package to have been registered`);
            const workspace = project.tryWorkspaceByLocator(pkg);
            if (workspace) {
                workspaceDependents.push(workspace);
            }
            else {
                const originalPkg = project.originalPackages.get(pkg.locatorHash);
                if (!originalPkg)
                    throw new Error(`Assertion failed: Expected the original package to have been registered`);
                const originalDependency = originalPkg.dependencies.get(descriptor.identHash);
                if (!originalDependency)
                    throw new Error(`Assertion failed: Expected the original dependency to have been registered`);
                transitiveDependencies.set(originalDependency.descriptorHash, originalDependency);
            }
        }
        for (const workspace of workspaceDependents) {
            for (const dependencyType of core_1.Manifest.hardDependencies) {
                const originalDescriptor = workspace.manifest[dependencyType].get(locator.identHash);
                if (!originalDescriptor)
                    continue;
                const newDescriptor = patchUtils.makeDescriptor(originalDescriptor, {
                    parentLocator: null,
                    sourceDescriptor: core_1.structUtils.convertLocatorToDescriptor(locator),
                    patchPaths: [fslib_1.ppath.join(fslib_1.Filename.home, fslib_1.ppath.relative(project.cwd, patchPath))],
                });
                workspace.manifest[dependencyType].set(originalDescriptor.identHash, newDescriptor);
            }
        }
        for (const originalDescriptor of transitiveDependencies.values()) {
            const newDescriptor = patchUtils.makeDescriptor(originalDescriptor, {
                parentLocator: null,
                sourceDescriptor: core_1.structUtils.convertLocatorToDescriptor(locator),
                patchPaths: [fslib_1.ppath.join(fslib_1.Filename.home, fslib_1.ppath.relative(project.cwd, patchPath))],
            });
            project.topLevelWorkspace.manifest.resolutions.push({
                pattern: { descriptor: { fullName: core_1.structUtils.stringifyIdent(newDescriptor), description: originalDescriptor.range } },
                reference: newDescriptor.range,
            });
        }
        await project.persist();
    }
}
PatchCommitCommand.paths = [
    [`patch-commit`],
];
PatchCommitCommand.usage = clipanion_1.Command.Usage({
    description: `generate a patch out of a directory`,
    details: `
      By default, this will print a patchfile on stdout based on the diff between the folder passed in and the original version of the package. Such file is suitable for consumption with the \`patch:\` protocol.

      With the \`-s,--save\` option set, the patchfile won't be printed on stdout anymore and will instead be stored within a local file (by default kept within \`.yarn/patches\`, but configurable via the \`patchFolder\` setting). A \`resolutions\` entry will also be added to your top-level manifest, referencing the patched package via the \`patch:\` protocol.

      Note that only folders generated by \`yarn patch\` are accepted as valid input for \`yarn patch-commit\`.
    `,
});
exports.default = PatchCommitCommand;
