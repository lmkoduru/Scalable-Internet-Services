"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ModernEngine = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@yarnpkg/core");
const constraintUtils = tslib_1.__importStar(require("./constraintUtils"));
class ModernEngine {
    constructor(project) {
        this.project = project;
    }
    createEnvironment() {
        const workspaceIndex = new constraintUtils.Index([`cwd`, `ident`]);
        const dependencyIndex = new constraintUtils.Index([`workspace`, `type`, `ident`]);
        const packageIndex = new constraintUtils.Index([`ident`]);
        const result = {
            manifestUpdates: new Map(),
            reportedErrors: new Map(),
        };
        const packageItems = new Map();
        const workspaceItems = new Map();
        for (const pkg of this.project.storedPackages.values()) {
            const peerDependencies = Array.from(pkg.peerDependencies.values(), descriptor => {
                return [core_1.structUtils.stringifyIdent(descriptor), descriptor.range];
            });
            packageItems.set(pkg.locatorHash, {
                workspace: null,
                ident: core_1.structUtils.stringifyIdent(pkg),
                version: pkg.version,
                dependencies: new Map(),
                peerDependencies: new Map(peerDependencies.filter(([ident]) => pkg.peerDependenciesMeta.get(ident)?.optional !== true)),
                optionalPeerDependencies: new Map(peerDependencies.filter(([ident]) => pkg.peerDependenciesMeta.get(ident)?.optional === true)),
            });
        }
        for (const pkg of this.project.storedPackages.values()) {
            const packageItem = packageItems.get(pkg.locatorHash);
            packageItem.dependencies = new Map(Array.from(pkg.dependencies.values(), descriptor => {
                const resolution = this.project.storedResolutions.get(descriptor.descriptorHash);
                if (typeof resolution === `undefined`)
                    throw new Error(`Assertion failed: The resolution should have been registered`);
                const pkg = packageItems.get(resolution);
                if (typeof pkg === `undefined`)
                    throw new Error(`Assertion failed: The package should have been registered`);
                return [core_1.structUtils.stringifyIdent(descriptor), pkg];
            }));
            packageItem.dependencies.delete(packageItem.ident);
        }
        for (const workspace of this.project.workspaces) {
            const ident = core_1.structUtils.stringifyIdent(workspace.anchoredLocator);
            const manifest = workspace.manifest.exportTo({});
            const pkg = packageItems.get(workspace.anchoredLocator.locatorHash);
            if (typeof pkg === `undefined`)
                throw new Error(`Assertion failed: The package should have been registered`);
            const setFn = (path, value, { caller = core_1.nodeUtils.getCaller() } = {}) => {
                const normalizedPath = constraintUtils.normalizePath(path);
                const workspaceUpdates = core_1.miscUtils.getMapWithDefault(result.manifestUpdates, workspace.cwd);
                const pathUpdates = core_1.miscUtils.getMapWithDefault(workspaceUpdates, normalizedPath);
                const constraints = core_1.miscUtils.getSetWithDefault(pathUpdates, value);
                if (caller !== null) {
                    constraints.add(caller);
                }
            };
            const unsetFn = (path) => {
                return setFn(path, undefined, { caller: core_1.nodeUtils.getCaller() });
            };
            const errorFn = (message) => {
                core_1.miscUtils.getArrayWithDefault(result.reportedErrors, workspace.cwd).push(message);
            };
            const workspaceItem = workspaceIndex.insert({
                cwd: workspace.relativeCwd,
                ident,
                manifest,
                pkg,
                set: setFn,
                unset: unsetFn,
                error: errorFn,
            });
            workspaceItems.set(workspace, workspaceItem);
            for (const dependencyType of core_1.Manifest.allDependencies) {
                for (const descriptor of workspace.manifest[dependencyType].values()) {
                    const ident = core_1.structUtils.stringifyIdent(descriptor);
                    const deleteFn = () => {
                        setFn([dependencyType, ident], undefined, { caller: core_1.nodeUtils.getCaller() });
                    };
                    const updateFn = (range) => {
                        setFn([dependencyType, ident], range, { caller: core_1.nodeUtils.getCaller() });
                    };
                    let resolutionItem = null;
                    if (dependencyType !== `peerDependencies`) {
                        if (dependencyType !== `dependencies` || !workspace.manifest.devDependencies.has(descriptor.identHash)) {
                            const pkgDescriptor = workspace.anchoredPackage.dependencies.get(descriptor.identHash);
                            // The descriptors may be missing if the package was added to the
                            // workspace after the constraints were computed (e.g. when using
                            // the `yarn constraints --fix` command)
                            if (pkgDescriptor) {
                                if (typeof pkgDescriptor === `undefined`)
                                    throw new Error(`Assertion failed: The dependency should have been registered`);
                                const resolution = this.project.storedResolutions.get(pkgDescriptor.descriptorHash);
                                if (typeof resolution === `undefined`)
                                    throw new Error(`Assertion failed: The resolution should have been registered`);
                                const pkgItem = packageItems.get(resolution);
                                if (typeof pkgItem === `undefined`)
                                    throw new Error(`Assertion failed: The package should have been registered`);
                                resolutionItem = pkgItem;
                            }
                        }
                    }
                    dependencyIndex.insert({
                        workspace: workspaceItem,
                        ident,
                        range: descriptor.range,
                        type: dependencyType,
                        resolution: resolutionItem,
                        update: updateFn,
                        delete: deleteFn,
                        error: errorFn,
                    });
                }
            }
        }
        for (const pkg of this.project.storedPackages.values()) {
            const workspace = this.project.tryWorkspaceByLocator(pkg);
            if (!workspace)
                continue;
            const workspaceItem = workspaceItems.get(workspace);
            if (typeof workspaceItem === `undefined`)
                throw new Error(`Assertion failed: The workspace should have been registered`);
            const packageItem = packageItems.get(pkg.locatorHash);
            if (typeof packageItem === `undefined`)
                throw new Error(`Assertion failed: The package should have been registered`);
            packageItem.workspace = workspaceItem;
        }
        return {
            workspaces: workspaceIndex,
            dependencies: dependencyIndex,
            packages: packageIndex,
            result,
        };
    }
    async process() {
        const env = this.createEnvironment();
        const context = {
            Yarn: {
                workspace: ((filter) => {
                    return env.workspaces.find(filter)[0] ?? null;
                }),
                workspaces: filter => {
                    return env.workspaces.find(filter);
                },
                dependency: ((filter) => {
                    return env.dependencies.find(filter)[0] ?? null;
                }),
                dependencies: filter => {
                    return env.dependencies.find(filter);
                },
                package: ((filter) => {
                    return env.packages.find(filter)[0] ?? null;
                }),
                packages: filter => {
                    return env.packages.find(filter);
                },
            },
        };
        const userConfig = await this.project.loadUserConfig();
        if (!userConfig?.constraints)
            return null;
        await userConfig.constraints(context);
        return env.result;
    }
}
exports.ModernEngine = ModernEngine;
