"use strict";
/// <reference path="./tauProlog.d.ts"/>
Object.defineProperty(exports, "__esModule", { value: true });
exports.linkProjectToSession = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@yarnpkg/core");
const get_1 = tslib_1.__importDefault(require("lodash/get"));
const tau_prolog_1 = tslib_1.__importDefault(require("tau-prolog"));
const vm_1 = tslib_1.__importDefault(require("vm"));
// eslint-disable-next-line @typescript-eslint/naming-convention
const { is_atom: isAtom, is_variable: isVariable, is_instantiated_list: isInstantiatedList } = tau_prolog_1.default.type;
function prependGoals(thread, point, goals) {
    thread.prepend(goals.map(goal => new tau_prolog_1.default.type.State(point.goal.replace(goal), point.substitution, point)));
}
const projects = new WeakMap();
function getProject(thread) {
    const project = projects.get(thread.session);
    if (project == null)
        throw new Error(`Assertion failed: A project should have been registered for the active session`);
    return project;
}
const tauModule = new tau_prolog_1.default.type.Module(`constraints`, {
    [`project_workspaces_by_descriptor/3`]: (thread, point, atom) => {
        const [descriptorIdent, descriptorRange, workspaceCwd] = atom.args;
        if (!isAtom(descriptorIdent) || !isAtom(descriptorRange)) {
            thread.throw_error(tau_prolog_1.default.error.instantiation(atom.indicator));
            return;
        }
        const ident = core_1.structUtils.parseIdent(descriptorIdent.id);
        const descriptor = core_1.structUtils.makeDescriptor(ident, descriptorRange.id);
        const project = getProject(thread);
        const workspace = project.tryWorkspaceByDescriptor(descriptor);
        if (isVariable(workspaceCwd)) {
            if (workspace !== null) {
                prependGoals(thread, point, [new tau_prolog_1.default.type.Term(`=`, [
                        workspaceCwd,
                        new tau_prolog_1.default.type.Term(String(workspace.relativeCwd)),
                    ])]);
            }
        }
        if (isAtom(workspaceCwd)) {
            if (workspace !== null && workspace.relativeCwd === workspaceCwd.id) {
                thread.success(point);
            }
        }
    },
    [`workspace_field/3`]: (thread, point, atom) => {
        const [workspaceCwd, fieldName, fieldValue] = atom.args;
        if (!isAtom(workspaceCwd) || !isAtom(fieldName)) {
            thread.throw_error(tau_prolog_1.default.error.instantiation(atom.indicator));
            return;
        }
        const project = getProject(thread);
        const workspace = project.tryWorkspaceByCwd(workspaceCwd.id);
        // Workspace not found => this predicate can never match
        // We might want to throw here? We can be pretty sure the user did
        // something wrong at this point
        if (workspace == null)
            return;
        const value = (0, get_1.default)(workspace.manifest.raw, fieldName.id);
        // Field is not present => this predicate can never match
        if (typeof value === `undefined`)
            return;
        prependGoals(thread, point, [new tau_prolog_1.default.type.Term(`=`, [
                fieldValue,
                // TODO: Investigate whether we should JSON.stringify primitive values too.
                // For now we don't because it would be a breaking change.
                // https://github.com/yarnpkg/berry/issues/3584
                new tau_prolog_1.default.type.Term(typeof value === `object` ? JSON.stringify(value) : value),
            ])]);
    },
    [`workspace_field_test/3`]: (thread, point, atom) => {
        const [workspaceCwd, fieldName, checkCode] = atom.args;
        thread.prepend([new tau_prolog_1.default.type.State(point.goal.replace(new tau_prolog_1.default.type.Term(`workspace_field_test`, [
                workspaceCwd,
                fieldName,
                checkCode,
                new tau_prolog_1.default.type.Term(`[]`, []),
            ])), point.substitution, point)]);
    },
    [`workspace_field_test/4`]: (thread, point, atom) => {
        const [workspaceCwd, fieldName, checkCode, checkArgv] = atom.args;
        if (!isAtom(workspaceCwd) || !isAtom(fieldName) || !isAtom(checkCode) || !isInstantiatedList(checkArgv)) {
            thread.throw_error(tau_prolog_1.default.error.instantiation(atom.indicator));
            return;
        }
        const project = getProject(thread);
        const workspace = project.tryWorkspaceByCwd(workspaceCwd.id);
        // Workspace not found => this predicate can never match
        // We might want to throw here? We can be pretty sure the user did
        // something wrong at this point
        if (workspace == null)
            return;
        const value = (0, get_1.default)(workspace.manifest.raw, fieldName.id);
        // Field is not present => this predicate can never match
        if (typeof value === `undefined`)
            return;
        // Inject the variables into a sandbox
        const vars = { $$: value };
        for (const [index, value] of checkArgv.toJavaScript().entries())
            vars[`$${index}`] = value;
        const result = vm_1.default.runInNewContext(checkCode.id, vars);
        if (result) {
            thread.success(point);
        }
    },
}, [
    `project_workspaces_by_descriptor/3`,
    `workspace_field/3`,
    `workspace_field_test/3`,
    `workspace_field_test/4`,
]);
function linkProjectToSession(session, project) {
    projects.set(session, project);
    session.consult(`:- use_module(library(${tauModule.id})).`);
}
exports.linkProjectToSession = linkProjectToSession;
