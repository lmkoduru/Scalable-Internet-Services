"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertReportToRoot = exports.applyEngineReport = exports.normalizePath = exports.Index = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@yarnpkg/core");
const get_1 = tslib_1.__importDefault(require("lodash/get"));
const set_1 = tslib_1.__importDefault(require("lodash/set"));
const toPath_1 = tslib_1.__importDefault(require("lodash/toPath"));
const unset_1 = tslib_1.__importDefault(require("lodash/unset"));
class Index {
    constructor(indexedFields) {
        this.indexedFields = indexedFields;
        this.items = [];
        this.indexes = {};
        this.clear();
    }
    clear() {
        this.items = [];
        for (const field of this.indexedFields) {
            this.indexes[field] = new Map();
        }
    }
    insert(item) {
        this.items.push(item);
        for (const field of this.indexedFields) {
            const value = Object.hasOwn(item, field)
                ? item[field]
                : undefined;
            if (typeof value === `undefined`)
                continue;
            const list = core_1.miscUtils.getArrayWithDefault(this.indexes[field], value);
            list.push(item);
        }
        return item;
    }
    find(filter) {
        if (typeof filter === `undefined`)
            return this.items;
        const filterEntries = Object.entries(filter);
        if (filterEntries.length === 0)
            return this.items;
        const sequentialFilters = [];
        let matches;
        for (const [field_, value] of filterEntries) {
            const field = field_;
            const index = Object.hasOwn(this.indexes, field)
                ? this.indexes[field]
                : undefined;
            if (typeof index === `undefined`) {
                sequentialFilters.push([field, value]);
                continue;
            }
            const filterMatches = new Set(index.get(value) ?? []);
            if (filterMatches.size === 0)
                return [];
            if (typeof matches === `undefined`) {
                matches = filterMatches;
            }
            else {
                for (const item of matches) {
                    if (!filterMatches.has(item)) {
                        matches.delete(item);
                    }
                }
            }
            if (matches.size === 0) {
                break;
            }
        }
        let result = [...matches ?? []];
        if (sequentialFilters.length > 0) {
            result = result.filter(item => {
                for (const [field, value] of sequentialFilters) {
                    const valid = typeof value !== `undefined`
                        ? Object.hasOwn(item, field) && item[field] === value
                        : Object.hasOwn(item, field) === false;
                    if (!valid) {
                        return false;
                    }
                }
                return true;
            });
        }
        return result;
    }
}
exports.Index = Index;
const numberRegExp = /^[0-9]+$/;
const identifierRegExp = /^[a-zA-Z0-9_]+$/;
const knownDictKeys = new Set([`scripts`, ...core_1.Manifest.allDependencies]);
function isKnownDict(parts, index) {
    return index === 1 && knownDictKeys.has(parts[0]);
}
function normalizePath(p) {
    const parts = Array.isArray(p)
        ? p
        : (0, toPath_1.default)(p);
    const normalizedParts = parts.map((part, t) => {
        if (numberRegExp.test(part))
            return `[${part}]`;
        if (identifierRegExp.test(part) && !isKnownDict(parts, t))
            return `.${part}`;
        return `[${JSON.stringify(part)}]`;
    });
    return normalizedParts.join(``).replace(/^\./, ``);
}
exports.normalizePath = normalizePath;
function formatStackLine(configuration, caller) {
    // TODO: Should this be in formatUtils? Might not be super useful as a core feature...
    const parts = [];
    if (caller.methodName !== null)
        parts.push(core_1.formatUtils.pretty(configuration, caller.methodName, core_1.formatUtils.Type.CODE));
    if (caller.file !== null) {
        const fileParts = [];
        fileParts.push(core_1.formatUtils.pretty(configuration, caller.file, core_1.formatUtils.Type.PATH));
        if (caller.line !== null) {
            fileParts.push(core_1.formatUtils.pretty(configuration, caller.line, core_1.formatUtils.Type.NUMBER));
            if (caller.column !== null) {
                fileParts.push(core_1.formatUtils.pretty(configuration, caller.column, core_1.formatUtils.Type.NUMBER));
            }
        }
        parts.push(`(${fileParts.join(core_1.formatUtils.pretty(configuration, `:`, `grey`))})`);
    }
    return parts.join(` `);
}
function applyEngineReport(project, { manifestUpdates, reportedErrors }, { fix } = {}) {
    const changedWorkspaces = new Map();
    const remainingErrors = new Map();
    const errorEntries = [...reportedErrors.keys()]
        .map(workspaceCwd => [workspaceCwd, new Map()]);
    for (const [workspaceCwd, workspaceUpdates] of [...errorEntries, ...manifestUpdates]) {
        const workspaceErrors = reportedErrors.get(workspaceCwd)?.map(text => ({ text, fixable: false })) ?? [];
        let changedWorkspace = false;
        const workspace = project.getWorkspaceByCwd(workspaceCwd);
        const manifest = workspace.manifest.exportTo({});
        for (const [fieldPath, newValues] of workspaceUpdates) {
            if (newValues.size > 1) {
                const conflictingValuesMessage = [...newValues].map(([value, sources]) => {
                    const prettyValue = core_1.formatUtils.pretty(project.configuration, value, core_1.formatUtils.Type.INSPECT);
                    const stackLine = sources.size > 0
                        ? formatStackLine(project.configuration, sources.values().next().value)
                        : null;
                    return stackLine !== null
                        ? `\n${prettyValue} at ${stackLine}`
                        : `\n${prettyValue}`;
                }).join(``);
                workspaceErrors.push({ text: `Conflict detected in constraint targeting ${core_1.formatUtils.pretty(project.configuration, fieldPath, core_1.formatUtils.Type.CODE)}; conflicting values are:${conflictingValuesMessage}`, fixable: false });
            }
            else {
                const [[newValue]] = newValues;
                const currentValue = (0, get_1.default)(manifest, fieldPath);
                if (JSON.stringify(currentValue) === JSON.stringify(newValue))
                    continue;
                if (!fix) {
                    const errorMessage = typeof currentValue === `undefined`
                        ? `Missing field ${core_1.formatUtils.pretty(project.configuration, fieldPath, core_1.formatUtils.Type.CODE)}; expected ${core_1.formatUtils.pretty(project.configuration, newValue, core_1.formatUtils.Type.INSPECT)}`
                        : typeof newValue === `undefined`
                            ? `Extraneous field ${core_1.formatUtils.pretty(project.configuration, fieldPath, core_1.formatUtils.Type.CODE)} currently set to ${core_1.formatUtils.pretty(project.configuration, currentValue, core_1.formatUtils.Type.INSPECT)}`
                            : `Invalid field ${core_1.formatUtils.pretty(project.configuration, fieldPath, core_1.formatUtils.Type.CODE)}; expected ${core_1.formatUtils.pretty(project.configuration, newValue, core_1.formatUtils.Type.INSPECT)}, found ${core_1.formatUtils.pretty(project.configuration, currentValue, core_1.formatUtils.Type.INSPECT)}`;
                    workspaceErrors.push({ text: errorMessage, fixable: true });
                    continue;
                }
                if (typeof newValue === `undefined`)
                    (0, unset_1.default)(manifest, fieldPath);
                else
                    (0, set_1.default)(manifest, fieldPath, newValue);
                changedWorkspace = true;
            }
            if (changedWorkspace) {
                changedWorkspaces.set(workspace, manifest);
            }
        }
        if (workspaceErrors.length > 0) {
            remainingErrors.set(workspace, workspaceErrors);
        }
    }
    return {
        changedWorkspaces,
        remainingErrors,
    };
}
exports.applyEngineReport = applyEngineReport;
function convertReportToRoot(errors, { configuration }) {
    const root = { children: [] };
    for (const [workspace, workspaceErrors] of errors) {
        const errorNodes = [];
        for (const error of workspaceErrors) {
            const lines = error.text.split(/\n/);
            if (error.fixable)
                lines[0] = `${core_1.formatUtils.pretty(configuration, `âš™`, `gray`)} ${lines[0]}`;
            errorNodes.push({
                value: core_1.formatUtils.tuple(core_1.formatUtils.Type.NO_HINT, lines[0]),
                children: lines.slice(1).map(line => ({
                    value: core_1.formatUtils.tuple(core_1.formatUtils.Type.NO_HINT, line),
                })),
            });
        }
        const workspaceNode = {
            value: core_1.formatUtils.tuple(core_1.formatUtils.Type.LOCATOR, workspace.anchoredLocator),
            children: core_1.miscUtils.sortMap(errorNodes, node => node.value[1]),
        };
        root.children.push(workspaceNode);
    }
    root.children = core_1.miscUtils.sortMap(root.children, node => {
        return node.value[1];
    });
    return root;
}
exports.convertReportToRoot = convertReportToRoot;
