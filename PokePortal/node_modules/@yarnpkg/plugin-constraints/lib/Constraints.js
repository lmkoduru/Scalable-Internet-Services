"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Constraints = exports.DependencyType = void 0;
const tslib_1 = require("tslib");
/// <reference path="./tauProlog.d.ts"/>
const core_1 = require("@yarnpkg/core");
const core_2 = require("@yarnpkg/core");
const fslib_1 = require("@yarnpkg/fslib");
// @ts-expect-error
const lists_1 = tslib_1.__importDefault(require("tau-prolog/modules/lists"));
const tau_prolog_1 = tslib_1.__importDefault(require("tau-prolog"));
const constraintUtils = tslib_1.__importStar(require("./constraintUtils"));
const tauModule_1 = require("./tauModule");
(0, lists_1.default)(tau_prolog_1.default);
var DependencyType;
(function (DependencyType) {
    DependencyType["Dependencies"] = "dependencies";
    DependencyType["DevDependencies"] = "devDependencies";
    DependencyType["PeerDependencies"] = "peerDependencies";
})(DependencyType || (exports.DependencyType = DependencyType = {}));
const DEPENDENCY_TYPES = [
    DependencyType.Dependencies,
    DependencyType.DevDependencies,
    DependencyType.PeerDependencies,
];
function extractErrorImpl(value) {
    if (value instanceof tau_prolog_1.default.type.Num)
        return value.value;
    if (value instanceof tau_prolog_1.default.type.Term) {
        switch (value.indicator) {
            case `throw/1`:
                return extractErrorImpl(value.args[0]);
            case `error/1`:
                return extractErrorImpl(value.args[0]);
            case `error/2`:
                if (value.args[0] instanceof tau_prolog_1.default.type.Term && value.args[0].indicator === `syntax_error/1`) {
                    return Object.assign(extractErrorImpl(value.args[0]), ...extractErrorImpl(value.args[1]));
                }
                else {
                    const err = extractErrorImpl(value.args[0]);
                    err.message += ` (in ${extractErrorImpl(value.args[1])})`;
                    return err;
                }
            case `syntax_error/1`:
                return new core_1.ReportError(core_1.MessageName.PROLOG_SYNTAX_ERROR, `Syntax error: ${extractErrorImpl(value.args[0])}`);
            case `existence_error/2`:
                return new core_1.ReportError(core_1.MessageName.PROLOG_EXISTENCE_ERROR, `Existence error: ${extractErrorImpl(value.args[0])} ${extractErrorImpl(value.args[1])} not found`);
            case `instantiation_error/0`:
                return new core_1.ReportError(core_1.MessageName.PROLOG_INSTANTIATION_ERROR, `Instantiation error: an argument is variable when an instantiated argument was expected`);
            case `line/1`:
                return { line: extractErrorImpl(value.args[0]) };
            case `column/1`:
                return { column: extractErrorImpl(value.args[0]) };
            case `found/1`:
                return { found: extractErrorImpl(value.args[0]) };
            case `./2`:
                return [extractErrorImpl(value.args[0])].concat(extractErrorImpl(value.args[1]));
            case `//2`:
                return `${extractErrorImpl(value.args[0])}/${extractErrorImpl(value.args[1])}`;
            default:
                return value.id;
        }
    }
    throw `couldn't pretty print because of unsupported node ${value}`;
}
function extractError(val) {
    let err;
    try {
        err = extractErrorImpl(val);
    }
    catch (caught) {
        if (typeof caught === `string`) {
            throw new core_1.ReportError(core_1.MessageName.PROLOG_UNKNOWN_ERROR, `Unknown error: ${val} (note: ${caught})`);
        }
        else {
            throw caught;
        }
    }
    if (typeof err.line !== `undefined` && typeof err.column !== `undefined`)
        err.message += ` at line ${err.line}, column ${err.column}`;
    return err;
}
class Session {
    constructor(project, source) {
        // The default Tau Prolog resolution steps limit is quite small
        // By using a proportional limit (instead of no limit), we avoid triggering pathological cases "easily"
        // See https://github.com/yarnpkg/berry/issues/1260
        const limit = 1000 * project.workspaces.length;
        this.session = tau_prolog_1.default.create(limit);
        (0, tauModule_1.linkProjectToSession)(this.session, project);
        this.session.consult(`:- use_module(library(lists)).`);
        this.session.consult(source);
    }
    fetchNextAnswer() {
        return new Promise(resolve => {
            this.session.answer((result) => {
                resolve(result);
            });
        });
    }
    async *makeQuery(query) {
        const parsed = this.session.query(query);
        if (parsed !== true)
            throw extractError(parsed);
        while (true) {
            const answer = await this.fetchNextAnswer();
            if (answer === null)
                throw new core_1.ReportError(core_1.MessageName.PROLOG_LIMIT_EXCEEDED, `Resolution limit exceeded`);
            if (!answer)
                break;
            if (answer.id === `throw`)
                throw extractError(answer);
            yield answer;
        }
    }
}
function parseLink(link) {
    if (link.id === `null`) {
        return null;
    }
    else {
        return `${link.toJavaScript()}`;
    }
}
function parseLinkToJson(link) {
    if (link.id === `null`) {
        return null;
    }
    else {
        const val = link.toJavaScript();
        if (typeof val !== `string`)
            return JSON.stringify(val);
        try {
            return JSON.stringify(JSON.parse(val));
        }
        catch {
            return JSON.stringify(val);
        }
    }
}
class Constraints {
    static async find(project) {
        return new Constraints(project);
    }
    constructor(project) {
        this.source = ``;
        this.project = project;
        const constraintsPath = project.configuration.get(`constraintsPath`);
        if (fslib_1.xfs.existsSync(constraintsPath)) {
            this.source = fslib_1.xfs.readFileSync(constraintsPath, `utf8`);
        }
    }
    getProjectDatabase() {
        let database = ``;
        for (const dependencyType of DEPENDENCY_TYPES)
            database += `dependency_type(${dependencyType}).\n`;
        for (const workspace of this.project.workspacesByCwd.values()) {
            const relativeCwd = workspace.relativeCwd;
            database += `workspace(${escape(relativeCwd)}).\n`;
            database += `workspace_ident(${escape(relativeCwd)}, ${escape(core_2.structUtils.stringifyIdent(workspace.anchoredLocator))}).\n`;
            database += `workspace_version(${escape(relativeCwd)}, ${escape(workspace.manifest.version)}).\n`;
            for (const dependencyType of DEPENDENCY_TYPES) {
                for (const dependency of workspace.manifest[dependencyType].values()) {
                    database += `workspace_has_dependency(${escape(relativeCwd)}, ${escape(core_2.structUtils.stringifyIdent(dependency))}, ${escape(dependency.range)}, ${dependencyType}).\n`;
                }
            }
        }
        // Add default never matching predicates to prevent prolog instantiation errors
        // when constraints run in an empty workspace
        database += `workspace(_) :- false.\n`;
        database += `workspace_ident(_, _) :- false.\n`;
        database += `workspace_version(_, _) :- false.\n`;
        // Add a default never matching predicate to prevent prolog instantiation errors
        // when constraints run in a workspace without dependencies
        database += `workspace_has_dependency(_, _, _, _) :- false.\n`;
        return database;
    }
    getDeclarations() {
        let declarations = ``;
        // (Cwd, DependencyIdent, DependencyRange, DependencyType)
        declarations += `gen_enforced_dependency(_, _, _, _) :- false.\n`;
        // (Cwd, Path, Value)
        declarations += `gen_enforced_field(_, _, _) :- false.\n`;
        return declarations;
    }
    get fullSource() {
        return `${this.getProjectDatabase()}\n${this.source}\n${this.getDeclarations()}`;
    }
    createSession() {
        return new Session(this.project, this.fullSource);
    }
    async processClassic() {
        const session = this.createSession();
        return {
            enforcedDependencies: await this.genEnforcedDependencies(session),
            enforcedFields: await this.genEnforcedFields(session),
        };
    }
    async process() {
        const { enforcedDependencies, enforcedFields, } = await this.processClassic();
        const manifestUpdates = new Map();
        for (const { workspace, dependencyIdent, dependencyRange, dependencyType } of enforcedDependencies) {
            const normalizedPath = constraintUtils.normalizePath([dependencyType, core_2.structUtils.stringifyIdent(dependencyIdent)]);
            const workspaceUpdates = core_2.miscUtils.getMapWithDefault(manifestUpdates, workspace.cwd);
            const pathUpdates = core_2.miscUtils.getMapWithDefault(workspaceUpdates, normalizedPath);
            pathUpdates.set(dependencyRange ?? undefined, new Set());
        }
        for (const { workspace, fieldPath, fieldValue } of enforcedFields) {
            const normalizedPath = constraintUtils.normalizePath(fieldPath);
            const workspaceUpdates = core_2.miscUtils.getMapWithDefault(manifestUpdates, workspace.cwd);
            const pathUpdates = core_2.miscUtils.getMapWithDefault(workspaceUpdates, normalizedPath);
            pathUpdates.set(JSON.parse(fieldValue) ?? undefined, new Set());
        }
        return {
            manifestUpdates,
            reportedErrors: new Map(),
        };
    }
    async genEnforcedDependencies(session) {
        const enforcedDependencies = [];
        for await (const answer of session.makeQuery(`workspace(WorkspaceCwd), dependency_type(DependencyType), gen_enforced_dependency(WorkspaceCwd, DependencyIdent, DependencyRange, DependencyType).`)) {
            const workspaceCwd = fslib_1.ppath.resolve(this.project.cwd, parseLink(answer.links.WorkspaceCwd));
            const dependencyRawIdent = parseLink(answer.links.DependencyIdent);
            const dependencyRange = parseLink(answer.links.DependencyRange);
            const dependencyType = parseLink(answer.links.DependencyType);
            if (workspaceCwd === null || dependencyRawIdent === null)
                throw new Error(`Invalid rule`);
            const workspace = this.project.getWorkspaceByCwd(workspaceCwd);
            const dependencyIdent = core_2.structUtils.parseIdent(dependencyRawIdent);
            enforcedDependencies.push({ workspace, dependencyIdent, dependencyRange, dependencyType });
        }
        return core_2.miscUtils.sortMap(enforcedDependencies, [
            ({ dependencyRange }) => dependencyRange !== null ? `0` : `1`,
            ({ workspace }) => core_2.structUtils.stringifyIdent(workspace.anchoredLocator),
            ({ dependencyIdent }) => core_2.structUtils.stringifyIdent(dependencyIdent),
        ]);
    }
    async genEnforcedFields(session) {
        const enforcedFields = [];
        for await (const answer of session.makeQuery(`workspace(WorkspaceCwd), gen_enforced_field(WorkspaceCwd, FieldPath, FieldValue).`)) {
            const workspaceCwd = fslib_1.ppath.resolve(this.project.cwd, parseLink(answer.links.WorkspaceCwd));
            const fieldPath = parseLink(answer.links.FieldPath);
            const fieldValue = parseLinkToJson(answer.links.FieldValue);
            if (workspaceCwd === null || fieldPath === null)
                throw new Error(`Invalid rule`);
            const workspace = this.project.getWorkspaceByCwd(workspaceCwd);
            enforcedFields.push({ workspace, fieldPath, fieldValue });
        }
        return core_2.miscUtils.sortMap(enforcedFields, [
            ({ workspace }) => core_2.structUtils.stringifyIdent(workspace.anchoredLocator),
            ({ fieldPath }) => fieldPath,
        ]);
    }
    async *query(query) {
        const session = this.createSession();
        for await (const answer of session.makeQuery(query)) {
            const parsedLinks = {};
            for (const [variable, value] of Object.entries(answer.links)) {
                if (variable !== `_`) {
                    parsedLinks[variable] = parseLink(value);
                }
            }
            yield parsedLinks;
        }
    }
}
exports.Constraints = Constraints;
function escape(what) {
    if (typeof what === `string`) {
        return `'${what}'`;
    }
    else {
        return `[]`;
    }
}
