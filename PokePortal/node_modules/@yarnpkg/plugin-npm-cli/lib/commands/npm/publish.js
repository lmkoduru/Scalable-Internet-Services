"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const cli_1 = require("@yarnpkg/cli");
const core_1 = require("@yarnpkg/core");
const plugin_npm_1 = require("@yarnpkg/plugin-npm");
const plugin_pack_1 = require("@yarnpkg/plugin-pack");
const clipanion_1 = require("clipanion");
// eslint-disable-next-line arca/no-default-export
class NpmPublishCommand extends cli_1.BaseCommand {
    constructor() {
        super(...arguments);
        this.access = clipanion_1.Option.String(`--access`, {
            description: `The access for the published package (public or restricted)`,
        });
        this.tag = clipanion_1.Option.String(`--tag`, `latest`, {
            description: `The tag on the registry that the package should be attached to`,
        });
        this.tolerateRepublish = clipanion_1.Option.Boolean(`--tolerate-republish`, false, {
            description: `Warn and exit when republishing an already existing version of a package`,
        });
        this.otp = clipanion_1.Option.String(`--otp`, {
            description: `The OTP token to use with the command`,
        });
    }
    async execute() {
        const configuration = await core_1.Configuration.find(this.context.cwd, this.context.plugins);
        const { project, workspace } = await core_1.Project.find(configuration, this.context.cwd);
        if (!workspace)
            throw new cli_1.WorkspaceRequiredError(project.cwd, this.context.cwd);
        if (workspace.manifest.private)
            throw new clipanion_1.UsageError(`Private workspaces cannot be published`);
        if (workspace.manifest.name === null || workspace.manifest.version === null)
            throw new clipanion_1.UsageError(`Workspaces must have valid names and versions to be published on an external registry`);
        await project.restoreInstallState();
        // We store it so that TS knows that it's non-null
        const ident = workspace.manifest.name;
        const version = workspace.manifest.version;
        const registry = plugin_npm_1.npmConfigUtils.getPublishRegistry(workspace.manifest, { configuration });
        const report = await core_1.StreamReport.start({
            configuration,
            stdout: this.context.stdout,
        }, async (report) => {
            // Not an error if --tolerate-republish is set
            if (this.tolerateRepublish) {
                try {
                    const registryData = await plugin_npm_1.npmHttpUtils.get(plugin_npm_1.npmHttpUtils.getIdentUrl(ident), {
                        configuration,
                        registry,
                        ident,
                        jsonResponse: true,
                    });
                    if (!Object.hasOwn(registryData, `versions`))
                        throw new core_1.ReportError(core_1.MessageName.REMOTE_INVALID, `Registry returned invalid data for - missing "versions" field`);
                    if (Object.hasOwn(registryData.versions, version)) {
                        report.reportWarning(core_1.MessageName.UNNAMED, `Registry already knows about version ${version}; skipping.`);
                        return;
                    }
                }
                catch (err) {
                    if (err.originalError?.response?.statusCode !== 404) {
                        throw err;
                    }
                }
            }
            await core_1.scriptUtils.maybeExecuteWorkspaceLifecycleScript(workspace, `prepublish`, { report });
            await plugin_pack_1.packUtils.prepareForPack(workspace, { report }, async () => {
                const files = await plugin_pack_1.packUtils.genPackList(workspace);
                for (const file of files)
                    report.reportInfo(null, file);
                const pack = await plugin_pack_1.packUtils.genPackStream(workspace, files);
                const buffer = await core_1.miscUtils.bufferStream(pack);
                const gitHead = await plugin_npm_1.npmPublishUtils.getGitHead(workspace.cwd);
                const body = await plugin_npm_1.npmPublishUtils.makePublishBody(workspace, buffer, {
                    access: this.access,
                    tag: this.tag,
                    registry,
                    gitHead,
                });
                await plugin_npm_1.npmHttpUtils.put(plugin_npm_1.npmHttpUtils.getIdentUrl(ident), body, {
                    configuration,
                    registry,
                    ident,
                    otp: this.otp,
                    jsonResponse: true,
                });
            });
            report.reportInfo(core_1.MessageName.UNNAMED, `Package archive published`);
        });
        return report.exitCode();
    }
}
NpmPublishCommand.paths = [
    [`npm`, `publish`],
];
NpmPublishCommand.usage = clipanion_1.Command.Usage({
    category: `Npm-related commands`,
    description: `publish the active workspace to the npm registry`,
    details: `
      This command will pack the active workspace into a fresh archive and upload it to the npm registry.

      The package will by default be attached to the \`latest\` tag on the registry, but this behavior can be overriden by using the \`--tag\` option.

      Note that for legacy reasons scoped packages are by default published with an access set to \`restricted\` (aka "private packages"). This requires you to register for a paid npm plan. In case you simply wish to publish a public scoped package to the registry (for free), just add the \`--access public\` flag. This behavior can be enabled by default through the \`npmPublishAccess\` settings.
    `,
    examples: [[
            `Publish the active workspace`,
            `yarn npm publish`,
        ]],
});
exports.default = NpmPublishCommand;
