"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getRegistry = void 0;
const cli_1 = require("@yarnpkg/cli");
const core_1 = require("@yarnpkg/core");
const core_2 = require("@yarnpkg/core");
const plugin_npm_1 = require("@yarnpkg/plugin-npm");
const clipanion_1 = require("clipanion");
const enquirer_1 = require("enquirer");
// eslint-disable-next-line arca/no-default-export
class NpmLoginCommand extends cli_1.BaseCommand {
    constructor() {
        super(...arguments);
        this.scope = clipanion_1.Option.String(`-s,--scope`, {
            description: `Login to the registry configured for a given scope`,
        });
        this.publish = clipanion_1.Option.Boolean(`--publish`, false, {
            description: `Login to the publish registry`,
        });
        this.alwaysAuth = clipanion_1.Option.Boolean(`--always-auth`, {
            description: `Set the npmAlwaysAuth configuration`,
        });
    }
    async execute() {
        const configuration = await core_1.Configuration.find(this.context.cwd, this.context.plugins);
        const registry = await getRegistry({
            configuration,
            cwd: this.context.cwd,
            publish: this.publish,
            scope: this.scope,
        });
        const report = await core_2.StreamReport.start({
            configuration,
            stdout: this.context.stdout,
            includeFooter: false,
        }, async (report) => {
            const credentials = await getCredentials({
                configuration,
                registry,
                report,
                stdin: this.context.stdin,
                stdout: this.context.stdout,
            });
            const url = `/-/user/org.couchdb.user:${encodeURIComponent(credentials.name)}`;
            const response = await plugin_npm_1.npmHttpUtils.put(url, credentials, {
                attemptedAs: credentials.name,
                configuration,
                registry,
                jsonResponse: true,
                authType: plugin_npm_1.npmHttpUtils.AuthType.NO_AUTH,
            });
            await setAuthToken(registry, response.token, { alwaysAuth: this.alwaysAuth, scope: this.scope });
            return report.reportInfo(core_1.MessageName.UNNAMED, `Successfully logged in`);
        });
        return report.exitCode();
    }
}
NpmLoginCommand.paths = [
    [`npm`, `login`],
];
NpmLoginCommand.usage = clipanion_1.Command.Usage({
    category: `Npm-related commands`,
    description: `store new login info to access the npm registry`,
    details: `
      This command will ask you for your username, password, and 2FA One-Time-Password (when it applies). It will then modify your local configuration (in your home folder, never in the project itself) to reference the new tokens thus generated.

      Adding the \`-s,--scope\` flag will cause the authentication to be done against whatever registry is configured for the associated scope (see also \`npmScopes\`).

      Adding the \`--publish\` flag will cause the authentication to be done against the registry used when publishing the package (see also \`publishConfig.registry\` and \`npmPublishRegistry\`).
    `,
    examples: [[
            `Login to the default registry`,
            `yarn npm login`,
        ], [
            `Login to the registry linked to the @my-scope registry`,
            `yarn npm login --scope my-scope`,
        ], [
            `Login to the publish registry for the current package`,
            `yarn npm login --publish`,
        ]],
});
exports.default = NpmLoginCommand;
async function getRegistry({ scope, publish, configuration, cwd }) {
    if (scope && publish)
        return plugin_npm_1.npmConfigUtils.getScopeRegistry(scope, { configuration, type: plugin_npm_1.npmConfigUtils.RegistryType.PUBLISH_REGISTRY });
    if (scope)
        return plugin_npm_1.npmConfigUtils.getScopeRegistry(scope, { configuration });
    if (publish)
        return plugin_npm_1.npmConfigUtils.getPublishRegistry((await (0, cli_1.openWorkspace)(configuration, cwd)).manifest, { configuration });
    return plugin_npm_1.npmConfigUtils.getDefaultRegistry({ configuration });
}
exports.getRegistry = getRegistry;
async function setAuthToken(registry, npmAuthToken, { alwaysAuth, scope }) {
    const makeUpdater = (entryName) => (unknownStore) => {
        const store = core_1.miscUtils.isIndexableObject(unknownStore)
            ? unknownStore
            : {};
        const entryUnknown = store[entryName];
        const entry = core_1.miscUtils.isIndexableObject(entryUnknown)
            ? entryUnknown
            : {};
        return {
            ...store,
            [entryName]: {
                ...entry,
                ...(alwaysAuth !== undefined ? { npmAlwaysAuth: alwaysAuth } : {}),
                npmAuthToken,
            },
        };
    };
    const update = scope
        ? { npmScopes: makeUpdater(scope) }
        : { npmRegistries: makeUpdater(registry) };
    return await core_1.Configuration.updateHomeConfiguration(update);
}
async function getCredentials({ configuration, registry, report, stdin, stdout }) {
    report.reportInfo(core_1.MessageName.UNNAMED, `Logging in to ${core_1.formatUtils.pretty(configuration, registry, core_1.formatUtils.Type.URL)}`);
    let isToken = false;
    if (registry.match(/^https:\/\/npm\.pkg\.github\.com(\/|$)/)) {
        report.reportInfo(core_1.MessageName.UNNAMED, `You seem to be using the GitHub Package Registry. Tokens must be generated with the 'repo', 'write:packages', and 'read:packages' permissions.`);
        isToken = true;
    }
    report.reportSeparator();
    if (configuration.env.YARN_IS_TEST_ENV) {
        return {
            name: configuration.env.YARN_INJECT_NPM_USER || ``,
            password: configuration.env.YARN_INJECT_NPM_PASSWORD || ``,
        };
    }
    const { username, password } = await (0, enquirer_1.prompt)([{
            type: `input`,
            name: `username`,
            message: `Username:`,
            required: true,
            onCancel: () => process.exit(130),
            stdin,
            stdout,
        }, {
            type: `password`,
            name: `password`,
            message: isToken ? `Token:` : `Password:`,
            required: true,
            onCancel: () => process.exit(130),
            stdin,
            stdout,
        }]);
    report.reportSeparator();
    return {
        name: username,
        password,
    };
}
