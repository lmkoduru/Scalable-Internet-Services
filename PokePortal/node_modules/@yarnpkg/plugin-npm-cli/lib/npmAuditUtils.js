"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPackages = exports.getTopLevelDependencies = exports.getReportTree = exports.getSeverityInclusions = exports.allSeverities = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@yarnpkg/core");
const semver_1 = tslib_1.__importDefault(require("semver"));
const npmAuditTypes = tslib_1.__importStar(require("./npmAuditTypes"));
exports.allSeverities = [
    npmAuditTypes.Severity.Info,
    npmAuditTypes.Severity.Low,
    npmAuditTypes.Severity.Moderate,
    npmAuditTypes.Severity.High,
    npmAuditTypes.Severity.Critical,
];
function getSeverityInclusions(severity) {
    if (typeof severity === `undefined`)
        return new Set(exports.allSeverities);
    const severityIndex = exports.allSeverities.indexOf(severity);
    const severities = exports.allSeverities.slice(severityIndex);
    return new Set(severities);
}
exports.getSeverityInclusions = getSeverityInclusions;
function getReportTree(result) {
    const auditTreeChildren = {};
    const auditTree = { children: auditTreeChildren };
    for (const [packageName, advisories] of core_1.miscUtils.sortMap(Object.entries(result), advisory => advisory[0])) {
        for (const advisory of core_1.miscUtils.sortMap(advisories, advisory => `${advisory.id}`)) {
            auditTreeChildren[`${packageName}/${advisory.id}`] = {
                value: core_1.formatUtils.tuple(core_1.formatUtils.Type.IDENT, core_1.structUtils.parseIdent(packageName)),
                children: {
                    ID: typeof advisory.id !== `undefined` && {
                        label: `ID`,
                        value: core_1.formatUtils.tuple(core_1.formatUtils.Type.ID, advisory.id),
                    },
                    Issue: {
                        label: `Issue`,
                        value: core_1.formatUtils.tuple(core_1.formatUtils.Type.NO_HINT, advisory.title),
                    },
                    URL: typeof advisory.url !== `undefined` && {
                        label: `URL`,
                        value: core_1.formatUtils.tuple(core_1.formatUtils.Type.URL, advisory.url),
                    },
                    Severity: {
                        label: `Severity`,
                        value: core_1.formatUtils.tuple(core_1.formatUtils.Type.NO_HINT, advisory.severity),
                    },
                    [`Vulnerable Versions`]: {
                        label: `Vulnerable Versions`,
                        value: core_1.formatUtils.tuple(core_1.formatUtils.Type.RANGE, advisory.vulnerable_versions),
                    },
                    [`Tree Versions`]: {
                        label: `Tree Versions`,
                        children: [...advisory.versions].sort(semver_1.default.compare).map(version => ({
                            value: core_1.formatUtils.tuple(core_1.formatUtils.Type.REFERENCE, version),
                        })),
                    },
                    Dependents: {
                        label: `Dependents`,
                        children: core_1.miscUtils.sortMap(advisory.dependents, locator => core_1.structUtils.stringifyLocator(locator)).map(locator => ({
                            value: core_1.formatUtils.tuple(core_1.formatUtils.Type.LOCATOR, locator),
                        })),
                    },
                },
            };
        }
    }
    return auditTree;
}
exports.getReportTree = getReportTree;
function getTopLevelDependencies(project, workspace, { all, environment }) {
    const topLevelDependencies = [];
    const workspaces = all
        ? project.workspaces
        : [workspace];
    const includeDependencies = [
        npmAuditTypes.Environment.All,
        npmAuditTypes.Environment.Production,
    ].includes(environment);
    const includeDevDependencies = [
        npmAuditTypes.Environment.All,
        npmAuditTypes.Environment.Development,
    ].includes(environment);
    for (const workspace of workspaces) {
        for (const dependency of workspace.anchoredPackage.dependencies.values()) {
            const isDevDependency = workspace.manifest.devDependencies.has(dependency.identHash);
            if (isDevDependency ? !includeDevDependencies : !includeDependencies)
                continue;
            topLevelDependencies.push({ workspace, dependency });
        }
    }
    return topLevelDependencies;
}
exports.getTopLevelDependencies = getTopLevelDependencies;
function getPackages(project, roots, { recursive }) {
    const packages = new Map();
    const traversed = new Set();
    const queue = [];
    const processDescriptor = (parent, descriptor) => {
        const resolution = project.storedResolutions.get(descriptor.descriptorHash);
        if (typeof resolution === `undefined`)
            throw new Error(`Assertion failed: The resolution should have been registered`);
        if (!traversed.has(resolution))
            traversed.add(resolution);
        else
            return;
        const pkg = project.storedPackages.get(resolution);
        if (typeof pkg === `undefined`)
            throw new Error(`Assertion failed: The package should have been registered`);
        const devirtualizedLocator = core_1.structUtils.ensureDevirtualizedLocator(pkg);
        if (devirtualizedLocator.reference.startsWith(`npm:`) && pkg.version !== null) {
            const packageName = core_1.structUtils.stringifyIdent(pkg);
            const versions = core_1.miscUtils.getMapWithDefault(packages, packageName);
            core_1.miscUtils.getArrayWithDefault(versions, pkg.version).push(parent);
        }
        if (recursive) {
            for (const dependency of pkg.dependencies.values()) {
                queue.push([pkg, dependency]);
            }
        }
    };
    for (const { workspace, dependency } of roots)
        queue.push([workspace.anchoredLocator, dependency]);
    while (queue.length > 0) {
        const [pkg, dependency] = queue.shift();
        processDescriptor(pkg, dependency);
    }
    return packages;
}
exports.getPackages = getPackages;
