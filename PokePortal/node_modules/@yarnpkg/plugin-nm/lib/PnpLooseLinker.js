"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PnpLooseLinker = void 0;
const core_1 = require("@yarnpkg/core");
const fslib_1 = require("@yarnpkg/fslib");
const libzip_1 = require("@yarnpkg/libzip");
const nm_1 = require("@yarnpkg/nm");
const plugin_pnp_1 = require("@yarnpkg/plugin-pnp");
const pnp_1 = require("@yarnpkg/pnp");
class PnpLooseLinker extends plugin_pnp_1.PnpLinker {
    constructor() {
        super(...arguments);
        this.mode = `loose`;
    }
    makeInstaller(opts) {
        return new PnpLooseInstaller(opts);
    }
}
exports.PnpLooseLinker = PnpLooseLinker;
class PnpLooseInstaller extends plugin_pnp_1.PnpInstaller {
    constructor() {
        super(...arguments);
        this.mode = `loose`;
    }
    async transformPnpSettings(pnpSettings) {
        const defaultFsLayer = new fslib_1.VirtualFS({
            baseFs: new libzip_1.ZipOpenFS({
                maxOpenFiles: 80,
                readOnlyArchives: true,
            }),
        });
        const pnp = (0, pnp_1.makeRuntimeApi)(pnpSettings, this.opts.project.cwd, defaultFsLayer);
        const { tree, errors } = (0, nm_1.buildNodeModulesTree)(pnp, { pnpifyFs: false, project: this.opts.project });
        if (!tree) {
            for (const { messageName, text } of errors)
                this.opts.report.reportError(messageName, text);
            return;
        }
        const fallbackPool = new Map();
        pnpSettings.fallbackPool = fallbackPool;
        const registerFallback = (name, entry) => {
            const locator = core_1.structUtils.parseLocator(entry.locator);
            const identStr = core_1.structUtils.stringifyIdent(locator);
            if (identStr === name) {
                fallbackPool.set(name, locator.reference);
            }
            else {
                fallbackPool.set(name, [identStr, locator.reference]);
            }
        };
        const root = fslib_1.ppath.join(this.opts.project.cwd, fslib_1.Filename.nodeModules);
        const entry = tree.get(root);
        // If there's no root junction point, it means that there are no dependencies to add to the fallback pool
        if (typeof entry === `undefined`)
            return;
        if (`target` in entry)
            throw new Error(`Assertion failed: Expected the root junction point to be a directory`);
        for (const childName of entry.dirList) {
            const childP = fslib_1.ppath.join(root, childName);
            const child = tree.get(childP);
            if (typeof child === `undefined`)
                throw new Error(`Assertion failed: Expected the child to have been registered`);
            if (`target` in child) {
                registerFallback(childName, child);
            }
            else {
                for (const subChildName of child.dirList) {
                    const subChildP = fslib_1.ppath.join(childP, subChildName);
                    const subChild = tree.get(subChildP);
                    if (typeof subChild === `undefined`)
                        throw new Error(`Assertion failed: Expected the subchild to have been registered`);
                    if (`target` in subChild) {
                        registerFallback(`${childName}/${subChildName}`, subChild);
                    }
                    else {
                        throw new Error(`Assertion failed: Expected the leaf junction to be a package`);
                    }
                }
            }
        }
    }
}
