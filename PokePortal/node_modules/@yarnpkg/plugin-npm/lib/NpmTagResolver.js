"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NpmTagResolver = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@yarnpkg/core");
const core_2 = require("@yarnpkg/core");
const semver_1 = tslib_1.__importDefault(require("semver"));
const NpmSemverFetcher_1 = require("./NpmSemverFetcher");
const constants_1 = require("./constants");
const npmHttpUtils = tslib_1.__importStar(require("./npmHttpUtils"));
class NpmTagResolver {
    supportsDescriptor(descriptor, opts) {
        if (!descriptor.range.startsWith(constants_1.PROTOCOL))
            return false;
        if (!core_1.TAG_REGEXP.test(descriptor.range.slice(constants_1.PROTOCOL.length)))
            return false;
        return true;
    }
    supportsLocator(locator, opts) {
        // Once transformed into locators, the tags are resolved by the NpmSemverResolver
        return false;
    }
    shouldPersistResolution(locator, opts) {
        // Once transformed into locators, the tags are resolved by the NpmSemverResolver
        throw new Error(`Unreachable`);
    }
    bindDescriptor(descriptor, fromLocator, opts) {
        return descriptor;
    }
    getResolutionDependencies(descriptor, opts) {
        return {};
    }
    async getCandidates(descriptor, dependencies, opts) {
        const tag = descriptor.range.slice(constants_1.PROTOCOL.length);
        const registryData = await npmHttpUtils.getPackageMetadata(descriptor, {
            cache: opts.fetchOptions?.cache,
            project: opts.project,
        });
        if (!Object.hasOwn(registryData, `dist-tags`))
            throw new core_1.ReportError(core_1.MessageName.REMOTE_INVALID, `Registry returned invalid data - missing "dist-tags" field`);
        const distTags = registryData[`dist-tags`];
        if (!Object.hasOwn(distTags, tag))
            throw new core_1.ReportError(core_1.MessageName.REMOTE_NOT_FOUND, `Registry failed to return tag "${tag}"`);
        const version = distTags[tag];
        const versionLocator = core_2.structUtils.makeLocator(descriptor, `${constants_1.PROTOCOL}${version}`);
        const archiveUrl = registryData.versions[version].dist.tarball;
        if (NpmSemverFetcher_1.NpmSemverFetcher.isConventionalTarballUrl(versionLocator, archiveUrl, { configuration: opts.project.configuration })) {
            return [versionLocator];
        }
        else {
            return [core_2.structUtils.bindLocator(versionLocator, { __archiveUrl: archiveUrl })];
        }
    }
    async getSatisfying(descriptor, dependencies, locators, opts) {
        const filtered = [];
        for (const locator of locators) {
            if (locator.identHash !== descriptor.identHash)
                continue;
            const parsedRange = core_2.structUtils.tryParseRange(locator.reference, { requireProtocol: constants_1.PROTOCOL });
            if (!parsedRange || !semver_1.default.valid(parsedRange.selector))
                continue;
            if (parsedRange.params?.__archiveUrl) {
                const newRange = core_2.structUtils.makeRange({ protocol: constants_1.PROTOCOL, selector: parsedRange.selector, source: null, params: null });
                const [resolvedLocator] = await opts.resolver.getCandidates(core_2.structUtils.makeDescriptor(descriptor, newRange), dependencies, opts);
                if (locator.reference !== resolvedLocator.reference) {
                    continue;
                }
            }
            filtered.push(locator);
        }
        return {
            locators: filtered,
            sorted: false,
        };
    }
    async resolve(locator, opts) {
        // Once transformed into locators (through getCandidates), the tags are resolved by the NpmSemverResolver
        throw new Error(`Unreachable`);
    }
}
exports.NpmTagResolver = NpmTagResolver;
