"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getReadmeContent = exports.getPublishAccess = exports.getGitHead = exports.makePublishBody = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@yarnpkg/core");
const core_2 = require("@yarnpkg/core");
const fslib_1 = require("@yarnpkg/fslib");
const plugin_pack_1 = require("@yarnpkg/plugin-pack");
const crypto_1 = require("crypto");
const ssri_1 = tslib_1.__importDefault(require("ssri"));
const url_1 = require("url");
const npmConfigUtils_1 = require("./npmConfigUtils");
async function makePublishBody(workspace, buffer, { access, tag, registry, gitHead }) {
    const ident = workspace.manifest.name;
    const version = workspace.manifest.version;
    const name = core_2.structUtils.stringifyIdent(ident);
    const shasum = (0, crypto_1.createHash)(`sha1`).update(buffer).digest(`hex`);
    const integrity = ssri_1.default.fromData(buffer).toString();
    const publishAccess = access ?? getPublishAccess(workspace, ident);
    const readmeContent = await getReadmeContent(workspace);
    const raw = await plugin_pack_1.packUtils.genPackageManifest(workspace);
    // This matches Lerna's logic:
    // https://github.com/evocateur/libnpmpublish/blob/latest/publish.js#L142
    // While the npm registry ignores the provided tarball URL, it's used by
    // other registries such as verdaccio.
    const tarballName = `${name}-${version}.tgz`;
    const tarballURL = new url_1.URL(`${(0, npmConfigUtils_1.normalizeRegistry)(registry)}/${name}/-/${tarballName}`);
    return {
        _id: name,
        _attachments: {
            [tarballName]: {
                [`content_type`]: `application/octet-stream`,
                data: buffer.toString(`base64`),
                length: buffer.length,
            },
        },
        name,
        access: publishAccess,
        [`dist-tags`]: {
            [tag]: version,
        },
        versions: {
            [version]: {
                ...raw,
                _id: `${name}@${version}`,
                name,
                version,
                gitHead,
                dist: {
                    shasum,
                    integrity,
                    // the npm registry requires a tarball path, but it seems useless ðŸ¤·
                    tarball: tarballURL.toString(),
                },
            },
        },
        readme: readmeContent,
    };
}
exports.makePublishBody = makePublishBody;
async function getGitHead(workingDir) {
    try {
        const { stdout } = await core_1.execUtils.execvp(`git`, [`rev-parse`, `--revs-only`, `HEAD`], { cwd: workingDir });
        if (stdout.trim() === ``)
            return undefined;
        return stdout.trim();
    }
    catch {
        return undefined;
    }
}
exports.getGitHead = getGitHead;
function getPublishAccess(workspace, ident) {
    const configuration = workspace.project.configuration;
    if (workspace.manifest.publishConfig && typeof workspace.manifest.publishConfig.access === `string`)
        return workspace.manifest.publishConfig.access;
    if (configuration.get(`npmPublishAccess`) !== null)
        return configuration.get(`npmPublishAccess`);
    const access = ident.scope
        ? `restricted`
        : `public`;
    return access;
}
exports.getPublishAccess = getPublishAccess;
async function getReadmeContent(workspace) {
    const readmePath = fslib_1.npath.toPortablePath(`${workspace.cwd}/README.md`);
    const ident = workspace.manifest.name;
    const packageName = core_2.structUtils.stringifyIdent(ident);
    let readme = `# ${packageName}\n`;
    try {
        readme = await fslib_1.xfs.readFilePromise(readmePath, `utf8`);
    }
    catch (err) {
        if (err.code === `ENOENT`) {
            return readme;
        }
        else {
            throw err;
        }
    }
    return readme;
}
exports.getReadmeContent = getReadmeContent;
