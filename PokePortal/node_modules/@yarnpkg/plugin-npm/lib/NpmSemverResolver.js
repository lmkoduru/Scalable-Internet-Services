"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NpmSemverResolver = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@yarnpkg/core");
const core_2 = require("@yarnpkg/core");
const core_3 = require("@yarnpkg/core");
const core_4 = require("@yarnpkg/core");
const semver_1 = tslib_1.__importDefault(require("semver"));
const NpmSemverFetcher_1 = require("./NpmSemverFetcher");
const constants_1 = require("./constants");
const npmHttpUtils = tslib_1.__importStar(require("./npmHttpUtils"));
const NODE_GYP_IDENT = core_4.structUtils.makeIdent(null, `node-gyp`);
const NODE_GYP_MATCH = /\b(node-gyp|prebuild-install)\b/;
class NpmSemverResolver {
    supportsDescriptor(descriptor, opts) {
        if (!descriptor.range.startsWith(constants_1.PROTOCOL))
            return false;
        return !!core_2.semverUtils.validRange(descriptor.range.slice(constants_1.PROTOCOL.length));
    }
    supportsLocator(locator, opts) {
        if (!locator.reference.startsWith(constants_1.PROTOCOL))
            return false;
        const { selector } = core_4.structUtils.parseRange(locator.reference);
        if (!semver_1.default.valid(selector))
            return false;
        return true;
    }
    shouldPersistResolution(locator, opts) {
        return true;
    }
    bindDescriptor(descriptor, fromLocator, opts) {
        return descriptor;
    }
    getResolutionDependencies(descriptor, opts) {
        return {};
    }
    async getCandidates(descriptor, dependencies, opts) {
        const range = core_2.semverUtils.validRange(descriptor.range.slice(constants_1.PROTOCOL.length));
        if (range === null)
            throw new Error(`Expected a valid range, got ${descriptor.range.slice(constants_1.PROTOCOL.length)}`);
        const registryData = await npmHttpUtils.getPackageMetadata(descriptor, {
            cache: opts.fetchOptions?.cache,
            project: opts.project,
            version: semver_1.default.valid(range.raw) ? range.raw : undefined,
        });
        const candidates = core_1.miscUtils.mapAndFilter(Object.keys(registryData.versions), version => {
            try {
                const candidate = new core_2.semverUtils.SemVer(version);
                if (range.test(candidate)) {
                    return candidate;
                }
            }
            catch { }
            return core_1.miscUtils.mapAndFilter.skip;
        });
        const noDeprecatedCandidates = candidates.filter(version => {
            return !registryData.versions[version.raw].deprecated;
        });
        // If there are versions that aren't deprecated, use them
        const finalCandidates = noDeprecatedCandidates.length > 0
            ? noDeprecatedCandidates
            : candidates;
        finalCandidates.sort((a, b) => {
            return -a.compare(b);
        });
        return finalCandidates.map(version => {
            const versionLocator = core_4.structUtils.makeLocator(descriptor, `${constants_1.PROTOCOL}${version.raw}`);
            const archiveUrl = registryData.versions[version.raw].dist.tarball;
            if (NpmSemverFetcher_1.NpmSemverFetcher.isConventionalTarballUrl(versionLocator, archiveUrl, { configuration: opts.project.configuration })) {
                return versionLocator;
            }
            else {
                return core_4.structUtils.bindLocator(versionLocator, { __archiveUrl: archiveUrl });
            }
        });
    }
    async getSatisfying(descriptor, dependencies, locators, opts) {
        const range = core_2.semverUtils.validRange(descriptor.range.slice(constants_1.PROTOCOL.length));
        if (range === null)
            throw new Error(`Expected a valid range, got ${descriptor.range.slice(constants_1.PROTOCOL.length)}`);
        const results = core_1.miscUtils.mapAndFilter(locators, locator => {
            if (locator.identHash !== descriptor.identHash)
                return core_1.miscUtils.mapAndFilter.skip;
            const parsedRange = core_4.structUtils.tryParseRange(locator.reference, { requireProtocol: constants_1.PROTOCOL });
            if (!parsedRange)
                return core_1.miscUtils.mapAndFilter.skip;
            const version = new core_2.semverUtils.SemVer(parsedRange.selector);
            if (!range.test(version))
                return core_1.miscUtils.mapAndFilter.skip;
            return { locator, version };
        });
        const sortedResults = results
            .sort((a, b) => -a.version.compare(b.version))
            .map(({ locator }) => locator);
        return {
            locators: sortedResults,
            sorted: true,
        };
    }
    async resolve(locator, opts) {
        const { selector } = core_4.structUtils.parseRange(locator.reference);
        const version = core_2.semverUtils.clean(selector);
        if (version === null)
            throw new core_1.ReportError(core_1.MessageName.RESOLVER_NOT_FOUND, `The npm semver resolver got selected, but the version isn't semver`);
        const registryData = await npmHttpUtils.getPackageMetadata(locator, {
            cache: opts.fetchOptions?.cache,
            project: opts.project,
            version,
        });
        if (!Object.hasOwn(registryData, `versions`))
            throw new core_1.ReportError(core_1.MessageName.REMOTE_INVALID, `Registry returned invalid data for - missing "versions" field`);
        if (!Object.hasOwn(registryData.versions, version))
            throw new core_1.ReportError(core_1.MessageName.REMOTE_NOT_FOUND, `Registry failed to return reference "${version}"`);
        const manifest = new core_1.Manifest();
        manifest.load(registryData.versions[version]);
        // Manually add node-gyp dependency if there is a script using it and not already set
        // This is because the npm registry will automatically add a `node-gyp rebuild` install script
        // in the metadata if there is not already an install script and a binding.gyp file exists.
        // Also, node-gyp is not always set as a dependency in packages, so it will also be added if used in scripts.
        if (!manifest.dependencies.has(NODE_GYP_IDENT.identHash) && !manifest.peerDependencies.has(NODE_GYP_IDENT.identHash)) {
            for (const value of manifest.scripts.values()) {
                if (value.match(NODE_GYP_MATCH)) {
                    manifest.dependencies.set(NODE_GYP_IDENT.identHash, core_4.structUtils.makeDescriptor(NODE_GYP_IDENT, `latest`));
                    break;
                }
            }
        }
        return {
            ...locator,
            version,
            languageName: `node`,
            linkType: core_3.LinkType.HARD,
            conditions: manifest.getConditions(),
            dependencies: opts.project.configuration.normalizeDependencyMap(manifest.dependencies),
            peerDependencies: manifest.peerDependencies,
            dependenciesMeta: manifest.dependenciesMeta,
            peerDependenciesMeta: manifest.peerDependenciesMeta,
            bin: manifest.bin,
        };
    }
}
exports.NpmSemverResolver = NpmSemverResolver;
