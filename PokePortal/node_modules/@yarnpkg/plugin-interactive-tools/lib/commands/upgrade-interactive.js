"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const cli_1 = require("@yarnpkg/cli");
const core_1 = require("@yarnpkg/core");
const libuiUtils = tslib_1.__importStar(require("@yarnpkg/libui/sources/libuiUtils"));
const plugin_essentials_1 = require("@yarnpkg/plugin-essentials");
const clipanion_1 = require("clipanion");
const diff_1 = require("diff");
const semver_1 = tslib_1.__importDefault(require("semver"));
const SIMPLE_SEMVER = /^((?:[\^~]|>=?)?)([0-9]+)(\.[0-9]+)(\.[0-9]+)((?:-\S+)?)$/;
// eslint-disable-next-line @typescript-eslint/comma-dangle -- the trailing comma is required because of parsing ambiguities
const partition = (array, size) => {
    return array.length > 0
        ? [array.slice(0, size)].concat(partition(array.slice(size), size))
        : [];
};
// eslint-disable-next-line arca/no-default-export
class UpgradeInteractiveCommand extends cli_1.BaseCommand {
    async execute() {
        libuiUtils.checkRequirements(this.context);
        const { ItemOptions } = await Promise.resolve().then(() => tslib_1.__importStar(require(`@yarnpkg/libui/sources/components/ItemOptions`)));
        const { Pad } = await Promise.resolve().then(() => tslib_1.__importStar(require(`@yarnpkg/libui/sources/components/Pad`)));
        const { ScrollableItems } = await Promise.resolve().then(() => tslib_1.__importStar(require(`@yarnpkg/libui/sources/components/ScrollableItems`)));
        const { useMinistore } = await Promise.resolve().then(() => tslib_1.__importStar(require(`@yarnpkg/libui/sources/hooks/useMinistore`)));
        const { renderForm } = await Promise.resolve().then(() => tslib_1.__importStar(require(`@yarnpkg/libui/sources/misc/renderForm`)));
        const { Box, Text } = await Promise.resolve().then(() => tslib_1.__importStar(require(`ink`)));
        const { default: React, useEffect, useRef, useState } = await Promise.resolve().then(() => tslib_1.__importStar(require(`react`)));
        const configuration = await core_1.Configuration.find(this.context.cwd, this.context.plugins);
        const { project, workspace } = await core_1.Project.find(configuration, this.context.cwd);
        const cache = await core_1.Cache.find(configuration);
        if (!workspace)
            throw new cli_1.WorkspaceRequiredError(project.cwd, this.context.cwd);
        await project.restoreInstallState({
            restoreResolutions: false,
        });
        // 7 = 1-line command written by the user
        //   + 2-line prompt
        //   + 1 newline
        //   + 1-line header
        //   + 1 newline
        //     [...package list]
        //   + 1 empty line
        const VIEWPORT_SIZE = this.context.stdout.rows - 7;
        const colorizeRawDiff = (from, to) => {
            const diff = (0, diff_1.diffWords)(from, to);
            let str = ``;
            for (const part of diff) {
                if (part.added) {
                    str += core_1.formatUtils.pretty(configuration, part.value, `green`);
                }
                else if (!part.removed) {
                    str += part.value;
                }
            }
            return str;
        };
        const colorizeVersionDiff = (from, to) => {
            if (from === to)
                return to;
            const parsedFrom = core_1.structUtils.parseRange(from);
            const parsedTo = core_1.structUtils.parseRange(to);
            const matchedFrom = parsedFrom.selector.match(SIMPLE_SEMVER);
            const matchedTo = parsedTo.selector.match(SIMPLE_SEMVER);
            if (!matchedFrom || !matchedTo)
                return colorizeRawDiff(from, to);
            const SEMVER_COLORS = [
                `gray`, // modifier
                `red`, // major
                `yellow`, // minor
                `green`, // patch
                `magenta`, // rc
            ];
            let color = null;
            let res = ``;
            for (let t = 1; t < SEMVER_COLORS.length; ++t) {
                if (color !== null || matchedFrom[t] !== matchedTo[t]) {
                    if (color === null)
                        color = SEMVER_COLORS[t - 1];
                    res += core_1.formatUtils.pretty(configuration, matchedTo[t], color);
                }
                else {
                    res += matchedTo[t];
                }
            }
            return res;
        };
        const fetchUpdatedDescriptor = async (descriptor, copyStyle, range) => {
            const candidate = await plugin_essentials_1.suggestUtils.fetchDescriptorFrom(descriptor, range, { project, cache, preserveModifier: copyStyle, workspace });
            if (candidate !== null) {
                return candidate.range;
            }
            else {
                return descriptor.range;
            }
        };
        const fetchSuggestions = async (descriptor) => {
            const referenceRange = semver_1.default.valid(descriptor.range)
                ? `^${descriptor.range}`
                : descriptor.range;
            const [resolution, latest] = await Promise.all([
                fetchUpdatedDescriptor(descriptor, descriptor.range, referenceRange).catch(() => null),
                fetchUpdatedDescriptor(descriptor, descriptor.range, `latest`).catch(() => null),
            ]);
            const suggestions = [{
                    value: null,
                    label: descriptor.range,
                }];
            if (resolution && resolution !== descriptor.range) {
                suggestions.push({
                    value: resolution,
                    label: colorizeVersionDiff(descriptor.range, resolution),
                });
            }
            else {
                suggestions.push({ value: null, label: `` });
            }
            if (latest && latest !== resolution && latest !== descriptor.range) {
                suggestions.push({
                    value: latest,
                    label: colorizeVersionDiff(descriptor.range, latest),
                });
            }
            else {
                suggestions.push({ value: null, label: `` });
            }
            return suggestions;
        };
        const Prompt = () => {
            return (React.createElement(Box, { flexDirection: `row` },
                React.createElement(Box, { flexDirection: `column`, width: 49 },
                    React.createElement(Box, { marginLeft: 1 },
                        React.createElement(Text, null,
                            "Press ",
                            React.createElement(Text, { bold: true, color: `cyanBright` }, `<up>`),
                            "/",
                            React.createElement(Text, { bold: true, color: `cyanBright` }, `<down>`),
                            " to select packages.")),
                    React.createElement(Box, { marginLeft: 1 },
                        React.createElement(Text, null,
                            "Press ",
                            React.createElement(Text, { bold: true, color: `cyanBright` }, `<left>`),
                            "/",
                            React.createElement(Text, { bold: true, color: `cyanBright` }, `<right>`),
                            " to select versions."))),
                React.createElement(Box, { flexDirection: `column` },
                    React.createElement(Box, { marginLeft: 1 },
                        React.createElement(Text, null,
                            "Press ",
                            React.createElement(Text, { bold: true, color: `cyanBright` }, `<enter>`),
                            " to install.")),
                    React.createElement(Box, { marginLeft: 1 },
                        React.createElement(Text, null,
                            "Press ",
                            React.createElement(Text, { bold: true, color: `cyanBright` }, `<ctrl+c>`),
                            " to abort.")))));
        };
        const Header = () => {
            return (React.createElement(Box, { flexDirection: `row`, paddingTop: 1, paddingBottom: 1 },
                React.createElement(Box, { width: 50 },
                    React.createElement(Text, { bold: true },
                        React.createElement(Text, { color: `greenBright` }, "?"),
                        " Pick the packages you want to upgrade.")),
                React.createElement(Box, { width: 17 },
                    React.createElement(Text, { bold: true, underline: true, color: `gray` }, "Current")),
                React.createElement(Box, { width: 17 },
                    React.createElement(Text, { bold: true, underline: true, color: `gray` }, "Range")),
                React.createElement(Box, { width: 17 },
                    React.createElement(Text, { bold: true, underline: true, color: `gray` }, "Latest"))));
        };
        const UpgradeEntry = ({ active, descriptor, suggestions }) => {
            const [action, setAction] = useMinistore(descriptor.descriptorHash, null);
            const packageIdentifier = core_1.structUtils.stringifyIdent(descriptor);
            const padLength = Math.max(0, 45 - packageIdentifier.length);
            return React.createElement(React.Fragment, null,
                React.createElement(Box, null,
                    React.createElement(Box, { width: 45 },
                        React.createElement(Text, { bold: true }, core_1.structUtils.prettyIdent(configuration, descriptor)),
                        React.createElement(Pad, { active: active, length: padLength })),
                    React.createElement(ItemOptions, { active: active, options: suggestions, value: action, skewer: true, onChange: setAction, sizes: [17, 17, 17] })));
        };
        const UpgradeEntries = ({ dependencies }) => {
            const [suggestions, setSuggestions] = useState(dependencies.map(() => null));
            const mountedRef = useRef(true);
            const getSuggestionsForDescriptor = async (descriptor) => {
                const suggestions = await fetchSuggestions(descriptor);
                if (suggestions.filter(suggestion => suggestion.label !== ``).length <= 1)
                    return null;
                return { descriptor, suggestions };
            };
            useEffect(() => {
                return () => {
                    mountedRef.current = false;
                };
            }, []);
            useEffect(() => {
                // Updating the invisible suggestions as they resolve causes continuous lag spikes while scrolling through the list of visible suggestions.
                // Because of that, we update the invisible suggestions in batches of VIEWPORT_SIZE.
                const foregroundDependencyCount = Math.trunc(VIEWPORT_SIZE * 1.75);
                const foregroundDependencies = dependencies.slice(0, foregroundDependencyCount);
                const backgroundDependencies = dependencies.slice(foregroundDependencyCount);
                const backgroundDependencyGroups = partition(backgroundDependencies, VIEWPORT_SIZE);
                const foregroundLock = foregroundDependencies
                    .map(getSuggestionsForDescriptor)
                    .reduce(async (lock, currentSuggestionPromise) => {
                    await lock;
                    const currentSuggestion = await currentSuggestionPromise;
                    if (currentSuggestion === null)
                        return;
                    if (!mountedRef.current)
                        return;
                    setSuggestions(suggestions => {
                        const firstEmptySlot = suggestions.findIndex(suggestion => suggestion === null);
                        const newSuggestions = [...suggestions];
                        newSuggestions[firstEmptySlot] = currentSuggestion;
                        return newSuggestions;
                    });
                }, Promise.resolve());
                backgroundDependencyGroups.reduce((lock, group) => Promise.all(group.map(descriptor => Promise.resolve().then(() => getSuggestionsForDescriptor(descriptor))))
                    .then(async (newSuggestions) => {
                    newSuggestions = newSuggestions.filter(suggestion => suggestion !== null);
                    await lock;
                    if (mountedRef.current) {
                        setSuggestions(suggestions => {
                            const firstEmptySlot = suggestions.findIndex(suggestion => suggestion === null);
                            return suggestions
                                .slice(0, firstEmptySlot)
                                .concat(newSuggestions)
                                .concat(suggestions.slice(firstEmptySlot + newSuggestions.length));
                        });
                    }
                }), foregroundLock).then(() => {
                    // Cleanup all empty slots
                    if (mountedRef.current) {
                        setSuggestions(suggestions => suggestions.filter(suggestion => suggestion !== null));
                    }
                });
            }, []);
            if (!suggestions.length)
                return React.createElement(Text, null, "No upgrades found");
            return React.createElement(ScrollableItems, { radius: VIEWPORT_SIZE >> 1, children: suggestions.map((suggestion, index) => {
                    // We use the same keys so that we don't lose the selection when a suggestion finishes loading
                    return suggestion !== null
                        ? React.createElement(UpgradeEntry, { key: index, active: false, descriptor: suggestion.descriptor, suggestions: suggestion.suggestions })
                        : React.createElement(Text, { key: index }, "Loading...");
                }) });
        };
        const GlobalListApp = ({ useSubmit }) => {
            useSubmit(useMinistore());
            const allDependencies = new Map();
            for (const workspace of project.workspaces)
                for (const dependencyType of [`dependencies`, `devDependencies`])
                    for (const descriptor of workspace.manifest[dependencyType].values())
                        if (project.tryWorkspaceByDescriptor(descriptor) === null)
                            if (!descriptor.range.startsWith(`link:`))
                                allDependencies.set(descriptor.descriptorHash, descriptor);
            const sortedDependencies = core_1.miscUtils.sortMap(allDependencies.values(), descriptor => {
                return core_1.structUtils.stringifyDescriptor(descriptor);
            });
            return React.createElement(Box, { flexDirection: `column` },
                React.createElement(Prompt, null),
                React.createElement(Header, null),
                React.createElement(UpgradeEntries, { dependencies: sortedDependencies }));
        };
        const updateRequests = await renderForm(GlobalListApp, {}, {
            stdin: this.context.stdin,
            stdout: this.context.stdout,
            stderr: this.context.stderr,
        });
        if (typeof updateRequests === `undefined`)
            return 1;
        let hasChanged = false;
        for (const workspace of project.workspaces) {
            for (const dependencyType of [`dependencies`, `devDependencies`]) {
                const dependencies = workspace.manifest[dependencyType];
                for (const descriptor of dependencies.values()) {
                    const newRange = updateRequests.get(descriptor.descriptorHash);
                    if (typeof newRange !== `undefined` && newRange !== null) {
                        dependencies.set(descriptor.identHash, core_1.structUtils.makeDescriptor(descriptor, newRange));
                        hasChanged = true;
                    }
                }
            }
        }
        if (!hasChanged)
            return 0;
        return await project.installWithNewReport({
            quiet: this.context.quiet,
            stdout: this.context.stdout,
        }, {
            cache,
        });
    }
}
UpgradeInteractiveCommand.paths = [
    [`upgrade-interactive`],
];
UpgradeInteractiveCommand.usage = clipanion_1.Command.Usage({
    category: `Interactive commands`,
    description: `open the upgrade interface`,
    details: `
      This command opens a fullscreen terminal interface where you can see any out of date packages used by your application, their status compared to the latest versions available on the remote registry, and select packages to upgrade.
    `,
    examples: [[
            `Open the upgrade window`,
            `yarn upgrade-interactive`,
        ]],
});
exports.default = UpgradeInteractiveCommand;
