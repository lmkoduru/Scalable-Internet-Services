"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.applyPrerelease = exports.applyReleases = exports.applyStrategy = exports.suggestStrategy = exports.getUndecidedDependentWorkspaces = exports.getUndecidedWorkspaces = exports.requireMoreDecisions = exports.openVersionFile = exports.updateVersionFiles = exports.clearVersionFiles = exports.resolveVersionFiles = exports.validateReleaseDecision = exports.Decision = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@yarnpkg/core");
const fslib_1 = require("@yarnpkg/fslib");
const parsers_1 = require("@yarnpkg/parsers");
const plugin_git_1 = require("@yarnpkg/plugin-git");
const clipanion_1 = require("clipanion");
const omit_1 = tslib_1.__importDefault(require("lodash/omit"));
const semver_1 = tslib_1.__importDefault(require("semver"));
// Basically we only support auto-upgrading the ranges that are very simple (^x.y.z, ~x.y.z, >=x.y.z, and of course x.y.z)
const SUPPORTED_UPGRADE_REGEXP = /^(>=|[~^]|)(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(-(0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(\.(0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*)?(\+[0-9a-zA-Z-]+(\.[0-9a-zA-Z-]+)*)?$/;
var Decision;
(function (Decision) {
    Decision["UNDECIDED"] = "undecided";
    Decision["DECLINE"] = "decline";
    Decision["MAJOR"] = "major";
    Decision["MINOR"] = "minor";
    Decision["PATCH"] = "patch";
    Decision["PRERELEASE"] = "prerelease";
})(Decision || (exports.Decision = Decision = {}));
function validateReleaseDecision(decision) {
    const semverDecision = semver_1.default.valid(decision);
    if (semverDecision)
        return semverDecision;
    return core_1.miscUtils.validateEnum((0, omit_1.default)(Decision, `UNDECIDED`), decision);
}
exports.validateReleaseDecision = validateReleaseDecision;
async function resolveVersionFiles(project, { prerelease = null } = {}) {
    let candidateReleases = new Map();
    const deferredVersionFolder = project.configuration.get(`deferredVersionFolder`);
    if (!fslib_1.xfs.existsSync(deferredVersionFolder))
        return candidateReleases;
    const deferredVersionFiles = await fslib_1.xfs.readdirPromise(deferredVersionFolder);
    for (const entry of deferredVersionFiles) {
        if (!entry.endsWith(`.yml`))
            continue;
        const versionPath = fslib_1.ppath.join(deferredVersionFolder, entry);
        const versionContent = await fslib_1.xfs.readFilePromise(versionPath, `utf8`);
        const versionData = (0, parsers_1.parseSyml)(versionContent);
        for (const [identStr, decision] of Object.entries(versionData.releases || {})) {
            if (decision === Decision.DECLINE)
                continue;
            const ident = core_1.structUtils.parseIdent(identStr);
            const workspace = project.tryWorkspaceByIdent(ident);
            if (workspace === null)
                throw new Error(`Assertion failed: Expected a release definition file to only reference existing workspaces (${fslib_1.ppath.basename(versionPath)} references ${identStr})`);
            if (workspace.manifest.version === null)
                throw new Error(`Assertion failed: Expected the workspace to have a version (${core_1.structUtils.prettyLocator(project.configuration, workspace.anchoredLocator)})`);
            // If there's a `stableVersion` field, then we assume that `version`
            // contains a prerelease version and that we need to base the version
            // bump relative to the latest stable instead.
            const baseVersion = workspace.manifest.raw.stableVersion ?? workspace.manifest.version;
            const candidateRelease = candidateReleases.get(workspace);
            const suggestedRelease = applyStrategy(baseVersion, validateReleaseDecision(decision));
            if (suggestedRelease === null)
                throw new Error(`Assertion failed: Expected ${baseVersion} to support being bumped via strategy ${decision}`);
            const bestRelease = typeof candidateRelease !== `undefined`
                ? semver_1.default.gt(suggestedRelease, candidateRelease) ? suggestedRelease : candidateRelease
                : suggestedRelease;
            candidateReleases.set(workspace, bestRelease);
        }
    }
    if (prerelease) {
        candidateReleases = new Map([...candidateReleases].map(([workspace, release]) => {
            return [workspace, applyPrerelease(release, { current: workspace.manifest.version, prerelease })];
        }));
    }
    return candidateReleases;
}
exports.resolveVersionFiles = resolveVersionFiles;
async function clearVersionFiles(project) {
    const deferredVersionFolder = project.configuration.get(`deferredVersionFolder`);
    if (!fslib_1.xfs.existsSync(deferredVersionFolder))
        return;
    await fslib_1.xfs.removePromise(deferredVersionFolder);
}
exports.clearVersionFiles = clearVersionFiles;
async function updateVersionFiles(project, workspaces) {
    const workspaceSet = new Set(workspaces);
    const deferredVersionFolder = project.configuration.get(`deferredVersionFolder`);
    if (!fslib_1.xfs.existsSync(deferredVersionFolder))
        return;
    const deferredVersionFiles = await fslib_1.xfs.readdirPromise(deferredVersionFolder);
    for (const entry of deferredVersionFiles) {
        if (!entry.endsWith(`.yml`))
            continue;
        const versionPath = fslib_1.ppath.join(deferredVersionFolder, entry);
        const versionContent = await fslib_1.xfs.readFilePromise(versionPath, `utf8`);
        const versionData = (0, parsers_1.parseSyml)(versionContent);
        const releases = versionData?.releases;
        if (!releases)
            continue;
        for (const locatorStr of Object.keys(releases)) {
            const ident = core_1.structUtils.parseIdent(locatorStr);
            const workspace = project.tryWorkspaceByIdent(ident);
            if (workspace === null || workspaceSet.has(workspace)) {
                delete versionData.releases[locatorStr];
            }
        }
        if (Object.keys(versionData.releases).length > 0) {
            await fslib_1.xfs.changeFilePromise(versionPath, (0, parsers_1.stringifySyml)(new parsers_1.stringifySyml.PreserveOrdering(versionData)));
        }
        else {
            await fslib_1.xfs.unlinkPromise(versionPath);
        }
    }
}
exports.updateVersionFiles = updateVersionFiles;
async function openVersionFile(project, { allowEmpty = false } = {}) {
    const configuration = project.configuration;
    if (configuration.projectCwd === null)
        throw new clipanion_1.UsageError(`This command can only be run from within a Yarn project`);
    const root = await plugin_git_1.gitUtils.fetchRoot(configuration.projectCwd);
    const base = root !== null
        ? await plugin_git_1.gitUtils.fetchBase(root, { baseRefs: configuration.get(`changesetBaseRefs`) })
        : null;
    const changedFiles = root !== null
        ? await plugin_git_1.gitUtils.fetchChangedFiles(root, { base: base.hash, project })
        : [];
    const deferredVersionFolder = configuration.get(`deferredVersionFolder`);
    const versionFiles = changedFiles.filter(p => fslib_1.ppath.contains(deferredVersionFolder, p) !== null);
    if (versionFiles.length > 1)
        throw new clipanion_1.UsageError(`Your current branch contains multiple versioning files; this isn't supported:\n- ${versionFiles.map(file => fslib_1.npath.fromPortablePath(file)).join(`\n- `)}`);
    const changedWorkspaces = new Set(core_1.miscUtils.mapAndFilter(changedFiles, file => {
        const workspace = project.tryWorkspaceByFilePath(file);
        if (workspace === null)
            return core_1.miscUtils.mapAndFilter.skip;
        return workspace;
    }));
    if (versionFiles.length === 0 && changedWorkspaces.size === 0 && !allowEmpty)
        return null;
    const versionPath = versionFiles.length === 1
        ? versionFiles[0]
        : fslib_1.ppath.join(deferredVersionFolder, `${core_1.hashUtils.makeHash(Math.random().toString()).slice(0, 8)}.yml`);
    const versionContent = fslib_1.xfs.existsSync(versionPath)
        ? await fslib_1.xfs.readFilePromise(versionPath, `utf8`)
        : `{}`;
    const versionData = (0, parsers_1.parseSyml)(versionContent);
    const releaseStore = new Map();
    for (const identStr of versionData.declined || []) {
        const ident = core_1.structUtils.parseIdent(identStr);
        const workspace = project.getWorkspaceByIdent(ident);
        releaseStore.set(workspace, Decision.DECLINE);
    }
    for (const [identStr, decision] of Object.entries(versionData.releases || {})) {
        const ident = core_1.structUtils.parseIdent(identStr);
        const workspace = project.getWorkspaceByIdent(ident);
        releaseStore.set(workspace, validateReleaseDecision(decision));
    }
    return {
        project,
        root,
        baseHash: base !== null
            ? base.hash
            : null,
        baseTitle: base !== null
            ? base.title
            : null,
        changedFiles: new Set(changedFiles),
        changedWorkspaces,
        releaseRoots: new Set([...changedWorkspaces].filter(workspace => workspace.manifest.version !== null)),
        releases: releaseStore,
        async saveAll() {
            const releases = {};
            const declined = [];
            const undecided = [];
            for (const workspace of project.workspaces) {
                // Let's assume that packages without versions don't need to see their version increased
                if (workspace.manifest.version === null)
                    continue;
                const identStr = core_1.structUtils.stringifyIdent(workspace.anchoredLocator);
                const decision = releaseStore.get(workspace);
                if (decision === Decision.DECLINE) {
                    declined.push(identStr);
                }
                else if (typeof decision !== `undefined`) {
                    releases[identStr] = validateReleaseDecision(decision);
                }
                else if (changedWorkspaces.has(workspace)) {
                    undecided.push(identStr);
                }
            }
            await fslib_1.xfs.mkdirPromise(fslib_1.ppath.dirname(versionPath), { recursive: true });
            await fslib_1.xfs.changeFilePromise(versionPath, (0, parsers_1.stringifySyml)(new parsers_1.stringifySyml.PreserveOrdering({
                releases: Object.keys(releases).length > 0 ? releases : undefined,
                declined: declined.length > 0 ? declined : undefined,
                undecided: undecided.length > 0 ? undecided : undefined,
            })));
        },
    };
}
exports.openVersionFile = openVersionFile;
function requireMoreDecisions(versionFile) {
    if (getUndecidedWorkspaces(versionFile).size > 0)
        return true;
    if (getUndecidedDependentWorkspaces(versionFile).length > 0)
        return true;
    return false;
}
exports.requireMoreDecisions = requireMoreDecisions;
function getUndecidedWorkspaces(versionFile) {
    const undecided = new Set();
    for (const workspace of versionFile.changedWorkspaces) {
        // Let's assume that packages without versions don't need to see their version increased
        if (workspace.manifest.version === null)
            continue;
        if (versionFile.releases.has(workspace))
            continue;
        undecided.add(workspace);
    }
    return undecided;
}
exports.getUndecidedWorkspaces = getUndecidedWorkspaces;
function getUndecidedDependentWorkspaces(versionFile, { include = new Set() } = {}) {
    const undecided = [];
    const bumpedWorkspaces = new Map(core_1.miscUtils.mapAndFilter([...versionFile.releases], ([workspace, decision]) => {
        if (decision === Decision.DECLINE)
            return core_1.miscUtils.mapAndFilter.skip;
        return [workspace.anchoredLocator.locatorHash, workspace];
    }));
    const declinedWorkspaces = new Map(core_1.miscUtils.mapAndFilter([...versionFile.releases], ([workspace, decision]) => {
        if (decision !== Decision.DECLINE)
            return core_1.miscUtils.mapAndFilter.skip;
        return [workspace.anchoredLocator.locatorHash, workspace];
    }));
    // Then we check which workspaces depend on packages that will be released again but have no release strategies themselves
    for (const workspace of versionFile.project.workspaces) {
        // We allow to overrule the following check because the interactive mode wants to keep displaying the previously-undecided packages even after they have been decided
        if (!include.has(workspace)) {
            // We don't need to run the check for packages that have already been decided
            if (declinedWorkspaces.has(workspace.anchoredLocator.locatorHash))
                continue;
            if (bumpedWorkspaces.has(workspace.anchoredLocator.locatorHash)) {
                continue;
            }
        }
        // Let's assume that packages without versions don't need to see their version increased
        if (workspace.manifest.version === null)
            continue;
        for (const dependencyType of core_1.Manifest.hardDependencies) {
            for (const descriptor of workspace.manifest.getForScope(dependencyType).values()) {
                const matchingWorkspace = versionFile.project.tryWorkspaceByDescriptor(descriptor);
                if (matchingWorkspace === null)
                    continue;
                // We only care about workspaces, and we only care about workspaces that will be bumped
                if (bumpedWorkspaces.has(matchingWorkspace.anchoredLocator.locatorHash)) {
                    // Quick note: we don't want to check whether the workspace pointer
                    // by `resolution` is private, because while it doesn't makes sense
                    // to bump a private package because its dependencies changed, the
                    // opposite isn't true: a (public) package might need to be bumped
                    // because one of its dev dependencies is a (private) package whose
                    // behavior sensibly changed.
                    undecided.push([workspace, matchingWorkspace]);
                }
            }
        }
    }
    return undecided;
}
exports.getUndecidedDependentWorkspaces = getUndecidedDependentWorkspaces;
function suggestStrategy(from, to) {
    const cleaned = semver_1.default.clean(to);
    for (const strategy of Object.values(Decision))
        if (strategy !== Decision.UNDECIDED && strategy !== Decision.DECLINE)
            if (semver_1.default.inc(from, strategy) === cleaned)
                return strategy;
    return null;
}
exports.suggestStrategy = suggestStrategy;
function applyStrategy(version, strategy) {
    if (semver_1.default.valid(strategy))
        return strategy;
    if (version === null)
        throw new clipanion_1.UsageError(`Cannot apply the release strategy "${strategy}" unless the workspace already has a valid version`);
    if (!semver_1.default.valid(version))
        throw new clipanion_1.UsageError(`Cannot apply the release strategy "${strategy}" on a non-semver version (${version})`);
    const nextVersion = semver_1.default.inc(version, strategy);
    if (nextVersion === null)
        throw new clipanion_1.UsageError(`Cannot apply the release strategy "${strategy}" on the specified version (${version})`);
    return nextVersion;
}
exports.applyStrategy = applyStrategy;
function applyReleases(project, newVersions, { report }) {
    const allDependents = new Map();
    // First we compute the reverse map to figure out which workspace is
    // depended upon by which other.
    //
    // Note that we need to do this before applying the new versions,
    // otherwise the `findWorkspacesByDescriptor` calls won't be able to
    // resolve the workspaces anymore (because the workspace versions will
    // have changed and won't match the outdated dependencies).
    for (const dependent of project.workspaces) {
        for (const set of core_1.Manifest.allDependencies) {
            for (const descriptor of dependent.manifest[set].values()) {
                const workspace = project.tryWorkspaceByDescriptor(descriptor);
                if (workspace === null)
                    continue;
                // We only care about workspaces that depend on a workspace that will
                // receive a fresh update
                if (!newVersions.has(workspace))
                    continue;
                const dependents = core_1.miscUtils.getArrayWithDefault(allDependents, workspace);
                dependents.push([dependent, set, descriptor.identHash]);
            }
        }
    }
    // Now that we know which workspaces depend on which others, we can
    // proceed to update everything at once using our accumulated knowledge.
    for (const [workspace, newVersion] of newVersions) {
        const oldVersion = workspace.manifest.version;
        workspace.manifest.version = newVersion;
        if (semver_1.default.prerelease(newVersion) === null)
            delete workspace.manifest.raw.stableVersion;
        else if (!workspace.manifest.raw.stableVersion)
            workspace.manifest.raw.stableVersion = oldVersion;
        const identString = workspace.manifest.name !== null
            ? core_1.structUtils.stringifyIdent(workspace.manifest.name)
            : null;
        report.reportInfo(core_1.MessageName.UNNAMED, `${core_1.structUtils.prettyLocator(project.configuration, workspace.anchoredLocator)}: Bumped to ${newVersion}`);
        report.reportJson({ cwd: fslib_1.npath.fromPortablePath(workspace.cwd), ident: identString, oldVersion, newVersion });
        const dependents = allDependents.get(workspace);
        if (typeof dependents === `undefined`)
            continue;
        for (const [dependent, set, identHash] of dependents) {
            const descriptor = dependent.manifest[set].get(identHash);
            if (typeof descriptor === `undefined`)
                throw new Error(`Assertion failed: The dependency should have existed`);
            let range = descriptor.range;
            let useWorkspaceProtocol = false;
            if (range.startsWith(core_1.WorkspaceResolver.protocol)) {
                range = range.slice(core_1.WorkspaceResolver.protocol.length);
                useWorkspaceProtocol = true;
                // Workspaces referenced through their path never get upgraded ("workspace:packages/yarnpkg-core")
                if (range === workspace.relativeCwd) {
                    continue;
                }
            }
            // We can only auto-upgrade the basic semver ranges (we can't auto-upgrade ">=1.0.0 <2.0.0", for example)
            const parsed = range.match(SUPPORTED_UPGRADE_REGEXP);
            if (!parsed) {
                report.reportWarning(core_1.MessageName.UNNAMED, `Couldn't auto-upgrade range ${range} (in ${core_1.structUtils.prettyLocator(project.configuration, dependent.anchoredLocator)})`);
                continue;
            }
            let newRange = `${parsed[1]}${newVersion}`;
            if (useWorkspaceProtocol)
                newRange = `${core_1.WorkspaceResolver.protocol}${newRange}`;
            const newDescriptor = core_1.structUtils.makeDescriptor(descriptor, newRange);
            dependent.manifest[set].set(identHash, newDescriptor);
        }
    }
}
exports.applyReleases = applyReleases;
const placeholders = new Map([
    [`%n`, {
            extract: parts => {
                if (parts.length >= 1) {
                    return [parts[0], parts.slice(1)];
                }
                else {
                    return null;
                }
            },
            generate: (previous = 0) => {
                return `${previous + 1}`;
            },
        }],
]);
function applyPrerelease(version, { current, prerelease }) {
    const currentVersion = new semver_1.default.SemVer(current);
    let currentPreParts = currentVersion.prerelease.slice();
    const nextPreParts = [];
    currentVersion.prerelease = [];
    // If the version we have in mind has nothing in common with the one we want,
    // we don't want to reuse its prerelease identifiers (1.0.0-rc.5 -> 1.1.0->rc.1)
    if (currentVersion.format() !== version)
        currentPreParts.length = 0;
    let patternMatched = true;
    const patternParts = prerelease.split(/\./g);
    for (const part of patternParts) {
        const placeholder = placeholders.get(part);
        if (typeof placeholder === `undefined`) {
            nextPreParts.push(part);
            if (currentPreParts[0] === part) {
                currentPreParts.shift();
            }
            else {
                patternMatched = false;
            }
        }
        else {
            const res = patternMatched
                ? placeholder.extract(currentPreParts)
                : null;
            if (res !== null && typeof res[0] === `number`) {
                nextPreParts.push(placeholder.generate(res[0]));
                currentPreParts = res[1];
            }
            else {
                nextPreParts.push(placeholder.generate());
                patternMatched = false;
            }
        }
    }
    if (currentVersion.prerelease)
        currentVersion.prerelease = [];
    return `${version}-${nextPreParts.join(`.`)}`;
}
exports.applyPrerelease = applyPrerelease;
