"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const cli_1 = require("@yarnpkg/cli");
const core_1 = require("@yarnpkg/core");
const fslib_1 = require("@yarnpkg/fslib");
const libuiUtils = tslib_1.__importStar(require("@yarnpkg/libui/sources/libuiUtils"));
const clipanion_1 = require("clipanion");
const semver_1 = tslib_1.__importDefault(require("semver"));
const versionUtils = tslib_1.__importStar(require("../../versionUtils"));
// eslint-disable-next-line arca/no-default-export
class VersionCheckCommand extends cli_1.BaseCommand {
    constructor() {
        super(...arguments);
        this.interactive = clipanion_1.Option.Boolean(`-i,--interactive`, {
            description: `Open an interactive interface used to set version bumps`,
        });
    }
    async execute() {
        if (this.interactive) {
            return await this.executeInteractive();
        }
        else {
            return await this.executeStandard();
        }
    }
    async executeInteractive() {
        libuiUtils.checkRequirements(this.context);
        const { Gem } = await Promise.resolve().then(() => tslib_1.__importStar(require(`@yarnpkg/libui/sources/components/Gem`)));
        const { ScrollableItems } = await Promise.resolve().then(() => tslib_1.__importStar(require(`@yarnpkg/libui/sources/components/ScrollableItems`)));
        const { FocusRequest } = await Promise.resolve().then(() => tslib_1.__importStar(require(`@yarnpkg/libui/sources/hooks/useFocusRequest`)));
        const { useListInput } = await Promise.resolve().then(() => tslib_1.__importStar(require(`@yarnpkg/libui/sources/hooks/useListInput`)));
        const { renderForm } = await Promise.resolve().then(() => tslib_1.__importStar(require(`@yarnpkg/libui/sources/misc/renderForm`)));
        const { Box, Text } = await Promise.resolve().then(() => tslib_1.__importStar(require(`ink`)));
        const { default: React, useCallback, useState } = await Promise.resolve().then(() => tslib_1.__importStar(require(`react`)));
        const configuration = await core_1.Configuration.find(this.context.cwd, this.context.plugins);
        const { project, workspace } = await core_1.Project.find(configuration, this.context.cwd);
        if (!workspace)
            throw new cli_1.WorkspaceRequiredError(project.cwd, this.context.cwd);
        await project.restoreInstallState();
        const versionFile = await versionUtils.openVersionFile(project);
        if (versionFile === null || versionFile.releaseRoots.size === 0)
            return 0;
        if (versionFile.root === null)
            throw new clipanion_1.UsageError(`This command can only be run on Git repositories`);
        const Prompt = () => {
            return (React.createElement(Box, { flexDirection: `row`, paddingBottom: 1 },
                React.createElement(Box, { flexDirection: `column`, width: 60 },
                    React.createElement(Box, null,
                        React.createElement(Text, null,
                            "Press ",
                            React.createElement(Text, { bold: true, color: `cyanBright` }, `<up>`),
                            "/",
                            React.createElement(Text, { bold: true, color: `cyanBright` }, `<down>`),
                            " to select workspaces.")),
                    React.createElement(Box, null,
                        React.createElement(Text, null,
                            "Press ",
                            React.createElement(Text, { bold: true, color: `cyanBright` }, `<left>`),
                            "/",
                            React.createElement(Text, { bold: true, color: `cyanBright` }, `<right>`),
                            " to select release strategies."))),
                React.createElement(Box, { flexDirection: `column` },
                    React.createElement(Box, { marginLeft: 1 },
                        React.createElement(Text, null,
                            "Press ",
                            React.createElement(Text, { bold: true, color: `cyanBright` }, `<enter>`),
                            " to save.")),
                    React.createElement(Box, { marginLeft: 1 },
                        React.createElement(Text, null,
                            "Press ",
                            React.createElement(Text, { bold: true, color: `cyanBright` }, `<ctrl+c>`),
                            " to abort.")))));
        };
        const Undecided = ({ workspace, active, decision, setDecision }) => {
            const currentVersion = workspace.manifest.raw.stableVersion ?? workspace.manifest.version;
            if (currentVersion === null)
                throw new Error(`Assertion failed: The version should have been set (${core_1.structUtils.prettyLocator(configuration, workspace.anchoredLocator)})`);
            if (semver_1.default.prerelease(currentVersion) !== null)
                throw new Error(`Assertion failed: Prerelease identifiers shouldn't be found (${currentVersion})`);
            const strategies = [
                versionUtils.Decision.UNDECIDED,
                versionUtils.Decision.DECLINE,
                versionUtils.Decision.PATCH,
                versionUtils.Decision.MINOR,
                versionUtils.Decision.MAJOR,
            ];
            useListInput(decision, strategies, {
                active: active,
                minus: `left`,
                plus: `right`,
                set: setDecision,
            });
            const nextVersion = decision === versionUtils.Decision.UNDECIDED
                ? React.createElement(Text, { color: `yellow` }, currentVersion)
                : decision === versionUtils.Decision.DECLINE
                    ? React.createElement(Text, { color: `green` }, currentVersion)
                    : React.createElement(Text, null,
                        React.createElement(Text, { color: `magenta` }, currentVersion),
                        " \u2192 ",
                        React.createElement(Text, { color: `green` }, semver_1.default.valid(decision)
                            ? decision
                            : semver_1.default.inc(currentVersion, decision)));
            return (React.createElement(Box, { flexDirection: `column` },
                React.createElement(Box, null,
                    React.createElement(Text, null,
                        core_1.structUtils.prettyLocator(configuration, workspace.anchoredLocator),
                        " - ",
                        nextVersion)),
                React.createElement(Box, null, strategies.map(strategy => {
                    const isGemActive = strategy === decision;
                    return (React.createElement(Box, { key: strategy, paddingLeft: 2 },
                        React.createElement(Text, null,
                            React.createElement(Gem, { active: isGemActive }),
                            " ",
                            strategy)));
                }))));
        };
        const getRelevancy = (releases) => {
            // Now, starting from all the workspaces that changed, we'll detect
            // which ones are affected by the choices that the user picked. By
            // doing this we'll "forget" all choices that aren't relevant any
            // longer (for example, imagine that the user decided to re-release
            // something, then its dependents, but then decided to not release
            // the original package anymore; then the dependents don't need to
            // released anymore)
            const relevantWorkspaces = new Set(versionFile.releaseRoots);
            const relevantReleases = new Map([...releases].filter(([workspace]) => {
                return relevantWorkspaces.has(workspace);
            }));
            while (true) {
                const undecidedDependentWorkspaces = versionUtils.getUndecidedDependentWorkspaces({
                    project: versionFile.project,
                    releases: relevantReleases,
                });
                let hasNewDependents = false;
                if (undecidedDependentWorkspaces.length > 0) {
                    for (const [workspace] of undecidedDependentWorkspaces) {
                        if (!relevantWorkspaces.has(workspace)) {
                            relevantWorkspaces.add(workspace);
                            hasNewDependents = true;
                            const release = releases.get(workspace);
                            if (typeof release !== `undefined`) {
                                relevantReleases.set(workspace, release);
                            }
                        }
                    }
                }
                if (!hasNewDependents) {
                    break;
                }
            }
            return {
                relevantWorkspaces,
                relevantReleases,
            };
        };
        const useReleases = () => {
            const [releases, setReleases] = useState(() => new Map(versionFile.releases));
            const setWorkspaceRelease = useCallback((workspace, decision) => {
                const copy = new Map(releases);
                if (decision !== versionUtils.Decision.UNDECIDED)
                    copy.set(workspace, decision);
                else
                    copy.delete(workspace);
                const { relevantReleases } = getRelevancy(copy);
                setReleases(relevantReleases);
            }, [releases, setReleases]);
            return [releases, setWorkspaceRelease];
        };
        const Stats = ({ workspaces, releases }) => {
            const parts = [];
            parts.push(`${workspaces.size} total`);
            let releaseCount = 0;
            let remainingCount = 0;
            for (const workspace of workspaces) {
                const release = releases.get(workspace);
                if (typeof release === `undefined`) {
                    remainingCount += 1;
                }
                else if (release !== versionUtils.Decision.DECLINE) {
                    releaseCount += 1;
                }
            }
            parts.push(`${releaseCount} release${releaseCount === 1 ? `` : `s`}`);
            parts.push(`${remainingCount} remaining`);
            return React.createElement(Text, { color: `yellow` }, parts.join(`, `));
        };
        const App = ({ useSubmit }) => {
            const [releases, setWorkspaceRelease] = useReleases();
            useSubmit(releases);
            const { relevantWorkspaces } = getRelevancy(releases);
            const dependentWorkspaces = new Set([...relevantWorkspaces].filter(workspace => {
                return !versionFile.releaseRoots.has(workspace);
            }));
            const [focus, setFocus] = useState(0);
            const handleFocusRequest = useCallback((request) => {
                switch (request) {
                    case FocusRequest.BEFORE:
                        {
                            setFocus(focus - 1);
                        }
                        break;
                    case FocusRequest.AFTER:
                        {
                            setFocus(focus + 1);
                        }
                        break;
                }
            }, [focus, setFocus]);
            return (React.createElement(Box, { flexDirection: `column` },
                React.createElement(Prompt, null),
                React.createElement(Box, null,
                    React.createElement(Text, { wrap: `wrap` }, "The following files have been modified in your local checkout.")),
                React.createElement(Box, { flexDirection: `column`, marginTop: 1, paddingLeft: 2 }, [...versionFile.changedFiles].map(file => (React.createElement(Box, { key: file },
                    React.createElement(Text, null,
                        React.createElement(Text, { color: `grey` }, fslib_1.npath.fromPortablePath(versionFile.root)),
                        fslib_1.npath.sep,
                        fslib_1.npath.relative(fslib_1.npath.fromPortablePath(versionFile.root), fslib_1.npath.fromPortablePath(file))))))),
                versionFile.releaseRoots.size > 0 && React.createElement(React.Fragment, null,
                    React.createElement(Box, { marginTop: 1 },
                        React.createElement(Text, { wrap: `wrap` }, "Because of those files having been modified, the following workspaces may need to be released again (note that private workspaces are also shown here, because even though they won't be published, releasing them will allow us to flag their dependents for potential re-release):")),
                    dependentWorkspaces.size > 3 ? React.createElement(Box, { marginTop: 1 },
                        React.createElement(Stats, { workspaces: versionFile.releaseRoots, releases: releases })) : null,
                    React.createElement(Box, { marginTop: 1, flexDirection: `column` },
                        React.createElement(ScrollableItems, { active: focus % 2 === 0, radius: 1, size: 2, onFocusRequest: handleFocusRequest }, [...versionFile.releaseRoots].map(workspace => (React.createElement(Undecided, { key: workspace.cwd, workspace: workspace, decision: releases.get(workspace) || versionUtils.Decision.UNDECIDED, setDecision: decision => setWorkspaceRelease(workspace, decision) })))))),
                dependentWorkspaces.size > 0 ? (React.createElement(React.Fragment, null,
                    React.createElement(Box, { marginTop: 1 },
                        React.createElement(Text, { wrap: `wrap` }, "The following workspaces depend on other workspaces that have been marked for release, and thus may need to be released as well:")),
                    React.createElement(Box, null,
                        React.createElement(Text, null,
                            "(Press ",
                            React.createElement(Text, { bold: true, color: `cyanBright` }, `<tab>`),
                            " to move the focus between the workspace groups.)")),
                    dependentWorkspaces.size > 5 ? (React.createElement(Box, { marginTop: 1 },
                        React.createElement(Stats, { workspaces: dependentWorkspaces, releases: releases }))) : null,
                    React.createElement(Box, { marginTop: 1, flexDirection: `column` },
                        React.createElement(ScrollableItems, { active: focus % 2 === 1, radius: 2, size: 2, onFocusRequest: handleFocusRequest }, [...dependentWorkspaces].map(workspace => (React.createElement(Undecided, { key: workspace.cwd, workspace: workspace, decision: releases.get(workspace) || versionUtils.Decision.UNDECIDED, setDecision: decision => setWorkspaceRelease(workspace, decision) }))))))) : null));
        };
        const decisions = await renderForm(App, { versionFile }, {
            stdin: this.context.stdin,
            stdout: this.context.stdout,
            stderr: this.context.stderr,
        });
        if (typeof decisions === `undefined`)
            return 1;
        versionFile.releases.clear();
        for (const [workspace, decision] of decisions)
            versionFile.releases.set(workspace, decision);
        await versionFile.saveAll();
        return undefined;
    }
    async executeStandard() {
        const configuration = await core_1.Configuration.find(this.context.cwd, this.context.plugins);
        const { project, workspace } = await core_1.Project.find(configuration, this.context.cwd);
        if (!workspace)
            throw new cli_1.WorkspaceRequiredError(project.cwd, this.context.cwd);
        await project.restoreInstallState();
        const report = await core_1.StreamReport.start({
            configuration,
            stdout: this.context.stdout,
        }, async (report) => {
            const versionFile = await versionUtils.openVersionFile(project);
            if (versionFile === null || versionFile.releaseRoots.size === 0)
                return;
            if (versionFile.root === null)
                throw new clipanion_1.UsageError(`This command can only be run on Git repositories`);
            report.reportInfo(core_1.MessageName.UNNAMED, `Your PR was started right after ${core_1.formatUtils.pretty(configuration, versionFile.baseHash.slice(0, 7), `yellow`)} ${core_1.formatUtils.pretty(configuration, versionFile.baseTitle, `magenta`)}`);
            if (versionFile.changedFiles.size > 0) {
                report.reportInfo(core_1.MessageName.UNNAMED, `You have changed the following files since then:`);
                report.reportSeparator();
                for (const file of versionFile.changedFiles) {
                    report.reportInfo(null, `${core_1.formatUtils.pretty(configuration, fslib_1.npath.fromPortablePath(versionFile.root), `gray`)}${fslib_1.npath.sep}${fslib_1.npath.relative(fslib_1.npath.fromPortablePath(versionFile.root), fslib_1.npath.fromPortablePath(file))}`);
                }
            }
            let hasDiffErrors = false;
            let hasDepsErrors = false;
            const undecided = versionUtils.getUndecidedWorkspaces(versionFile);
            if (undecided.size > 0) {
                if (!hasDiffErrors)
                    report.reportSeparator();
                for (const workspace of undecided)
                    report.reportError(core_1.MessageName.UNNAMED, `${core_1.structUtils.prettyLocator(configuration, workspace.anchoredLocator)} has been modified but doesn't have a release strategy attached`);
                hasDiffErrors = true;
            }
            const undecidedDependents = versionUtils.getUndecidedDependentWorkspaces(versionFile);
            // Then we check which workspaces depend on packages that will be released again but have no release strategies themselves
            for (const [workspace, dependency] of undecidedDependents) {
                if (!hasDepsErrors)
                    report.reportSeparator();
                report.reportError(core_1.MessageName.UNNAMED, `${core_1.structUtils.prettyLocator(configuration, workspace.anchoredLocator)} doesn't have a release strategy attached, but depends on ${core_1.structUtils.prettyWorkspace(configuration, dependency)} which is planned for release.`);
                hasDepsErrors = true;
            }
            if (hasDiffErrors || hasDepsErrors) {
                report.reportSeparator();
                report.reportInfo(core_1.MessageName.UNNAMED, `This command detected that at least some workspaces have received modifications without explicit instructions as to how they had to be released (if needed).`);
                report.reportInfo(core_1.MessageName.UNNAMED, `To correct these errors, run \`yarn version check --interactive\` then follow the instructions.`);
            }
        });
        return report.exitCode();
    }
}
VersionCheckCommand.paths = [
    [`version`, `check`],
];
VersionCheckCommand.usage = clipanion_1.Command.Usage({
    category: `Release-related commands`,
    description: `check that all the relevant packages have been bumped`,
    details: `
      **Warning:** This command currently requires Git.

      This command will check that all the packages covered by the files listed in argument have been properly bumped or declined to bump.

      In the case of a bump, the check will also cover transitive packages - meaning that should \`Foo\` be bumped, a package \`Bar\` depending on \`Foo\` will require a decision as to whether \`Bar\` will need to be bumped. This check doesn't cross packages that have declined to bump.

      In case no arguments are passed to the function, the list of modified files will be generated by comparing the HEAD against \`master\`.
    `,
    examples: [[
            `Check whether the modified packages need a bump`,
            `yarn version check`,
        ]],
});
exports.default = VersionCheckCommand;
