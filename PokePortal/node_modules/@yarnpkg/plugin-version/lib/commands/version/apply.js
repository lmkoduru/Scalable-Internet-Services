"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const cli_1 = require("@yarnpkg/cli");
const core_1 = require("@yarnpkg/core");
const core_2 = require("@yarnpkg/core");
const clipanion_1 = require("clipanion");
const versionUtils = tslib_1.__importStar(require("../../versionUtils"));
// eslint-disable-next-line arca/no-default-export
class VersionApplyCommand extends cli_1.BaseCommand {
    constructor() {
        super(...arguments);
        this.all = clipanion_1.Option.Boolean(`--all`, false, {
            description: `Apply the deferred version changes on all workspaces`,
        });
        this.dryRun = clipanion_1.Option.Boolean(`--dry-run`, false, {
            description: `Print the versions without actually generating the package archive`,
        });
        this.prerelease = clipanion_1.Option.String(`--prerelease`, {
            description: `Add a prerelease identifier to new versions`,
            tolerateBoolean: true,
        });
        this.recursive = clipanion_1.Option.Boolean(`-R,--recursive`, {
            description: `Release the transitive workspaces as well`,
        });
        this.json = clipanion_1.Option.Boolean(`--json`, false, {
            description: `Format the output as an NDJSON stream`,
        });
    }
    async execute() {
        const configuration = await core_1.Configuration.find(this.context.cwd, this.context.plugins);
        const { project, workspace } = await core_2.Project.find(configuration, this.context.cwd);
        const cache = await core_1.Cache.find(configuration);
        if (!workspace)
            throw new cli_1.WorkspaceRequiredError(project.cwd, this.context.cwd);
        await project.restoreInstallState({
            restoreResolutions: false,
        });
        const applyReport = await core_2.StreamReport.start({
            configuration,
            json: this.json,
            stdout: this.context.stdout,
        }, async (report) => {
            const prerelease = this.prerelease
                ? typeof this.prerelease !== `boolean` ? this.prerelease : `rc.%n`
                : null;
            const allReleases = await versionUtils.resolveVersionFiles(project, { prerelease });
            let filteredReleases = new Map();
            if (this.all) {
                filteredReleases = allReleases;
            }
            else {
                const relevantWorkspaces = this.recursive
                    ? workspace.getRecursiveWorkspaceDependencies()
                    : [workspace];
                for (const child of relevantWorkspaces) {
                    const release = allReleases.get(child);
                    if (typeof release !== `undefined`) {
                        filteredReleases.set(child, release);
                    }
                }
            }
            if (filteredReleases.size === 0) {
                const protip = allReleases.size > 0
                    ? ` Did you want to add --all?`
                    : ``;
                report.reportWarning(core_1.MessageName.UNNAMED, `The current workspace doesn't seem to require a version bump.${protip}`);
                return;
            }
            versionUtils.applyReleases(project, filteredReleases, { report });
            if (!this.dryRun) {
                if (!prerelease) {
                    if (this.all) {
                        await versionUtils.clearVersionFiles(project);
                    }
                    else {
                        await versionUtils.updateVersionFiles(project, [...filteredReleases.keys()]);
                    }
                }
                report.reportSeparator();
            }
        });
        if (applyReport.hasErrors())
            return applyReport.exitCode();
        return await project.installWithNewReport({
            json: this.json,
            stdout: this.context.stdout,
        }, {
            cache,
        });
    }
}
VersionApplyCommand.paths = [
    [`version`, `apply`],
];
VersionApplyCommand.usage = clipanion_1.Command.Usage({
    category: `Release-related commands`,
    description: `apply all the deferred version bumps at once`,
    details: `
      This command will apply the deferred version changes and remove their definitions from the repository.

      Note that if \`--prerelease\` is set, the given prerelease identifier (by default \`rc.%d\`) will be used on all new versions and the version definitions will be kept as-is.

      By default only the current workspace will be bumped, but you can configure this behavior by using one of:

      - \`--recursive\` to also apply the version bump on its dependencies
      - \`--all\` to apply the version bump on all packages in the repository

      Note that this command will also update the \`workspace:\` references across all your local workspaces, thus ensuring that they keep referring to the same workspaces even after the version bump.
    `,
    examples: [[
            `Apply the version change to the local workspace`,
            `yarn version apply`,
        ], [
            `Apply the version change to all the workspaces in the local workspace`,
            `yarn version apply --all`,
        ]],
});
exports.default = VersionApplyCommand;
