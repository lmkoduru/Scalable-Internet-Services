"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.runExit = exports.getCli = void 0;
const core_1 = require("@yarnpkg/core");
const fslib_1 = require("@yarnpkg/fslib");
const child_process_1 = require("child_process");
const ci_info_1 = require("ci-info");
const clipanion_1 = require("clipanion");
const pluginCommands_1 = require("./pluginCommands");
const getPluginConfiguration_1 = require("./tools/getPluginConfiguration");
function getBaseCli({ cwd, pluginConfiguration }) {
    const cli = new clipanion_1.Cli({
        binaryLabel: `Yarn Package Manager`,
        binaryName: `yarn`,
        binaryVersion: core_1.YarnVersion ?? `<unknown>`,
    });
    return Object.assign(cli, {
        defaultContext: {
            ...clipanion_1.Cli.defaultContext,
            cwd,
            plugins: pluginConfiguration,
            quiet: false,
            stdin: process.stdin,
            stdout: process.stdout,
            stderr: process.stderr,
        },
    });
}
function validateNodejsVersion(cli) {
    // YARN_IGNORE_NODE is special because this code needs to execute as early as possible.
    // It's not a regular core setting because Configuration.find may use functions not available
    // on older Node versions.
    const ignoreNode = core_1.miscUtils.parseOptionalBoolean(process.env.YARN_IGNORE_NODE);
    if (ignoreNode)
        return true;
    const version = process.versions.node;
    // Non-exhaustive known requirements:
    // - 18.12 is the first LTS release
    const range = `>=18.12.0`;
    if (core_1.semverUtils.satisfiesWithPrereleases(version, range))
        return true;
    const error = new clipanion_1.UsageError(`This tool requires a Node version compatible with ${range} (got ${version}). Upgrade Node, or set \`YARN_IGNORE_NODE=1\` in your environment.`);
    clipanion_1.Cli.defaultContext.stdout.write(cli.error(error));
    return false;
}
async function getCoreConfiguration({ selfPath, pluginConfiguration }) {
    // Since we only care about a few very specific settings we tolerate extra configuration key.
    // If we didn't, we wouldn't even be able to run `yarn config` (which is recommended in the invalid config error message)
    return await core_1.Configuration.find(fslib_1.npath.toPortablePath(process.cwd()), pluginConfiguration, {
        strict: false,
        usePathCheck: selfPath,
    });
}
function runYarnPath(cli, argv, { yarnPath }) {
    if (!fslib_1.xfs.existsSync(yarnPath)) {
        (cli.error(new Error(`The "yarn-path" option has been set, but the specified location doesn't exist (${yarnPath}).`)));
        return 1;
    }
    process.on(`SIGINT`, () => {
        // We don't want SIGINT to kill our process; we want it to kill the
        // innermost process, whose end will cause our own to exit.
    });
    const yarnPathExecOptions = {
        stdio: `inherit`,
        env: {
            ...process.env,
            YARN_IGNORE_PATH: `1`,
        },
    };
    try {
        (0, child_process_1.execFileSync)(process.execPath, [fslib_1.npath.fromPortablePath(yarnPath), ...argv], yarnPathExecOptions);
    }
    catch (err) {
        return err.status ?? 1;
    }
    return 0;
}
function checkCwd(cli, argv) {
    let cwd = null;
    let postCwdArgv = argv;
    if (argv.length >= 2 && argv[0] === `--cwd`) {
        cwd = fslib_1.npath.toPortablePath(argv[1]);
        postCwdArgv = argv.slice(2);
    }
    else if (argv.length >= 1 && argv[0].startsWith(`--cwd=`)) {
        cwd = fslib_1.npath.toPortablePath(argv[0].slice(6));
        postCwdArgv = argv.slice(1);
    }
    else if (argv[0] === `add` && argv[argv.length - 2] === `--cwd`) {
        // CRA adds `--cwd` at the end of the command; it's not ideal, but since
        // it's unlikely to receive more releases we can just special-case it
        // TODO v5: remove this special case
        cwd = fslib_1.npath.toPortablePath(argv[argv.length - 1]);
        postCwdArgv = argv.slice(0, argv.length - 2);
    }
    cli.defaultContext.cwd = cwd !== null
        ? fslib_1.ppath.resolve(cwd)
        : fslib_1.ppath.cwd();
    return postCwdArgv;
}
function initTelemetry(cli, { configuration }) {
    const isTelemetryEnabled = configuration.get(`enableTelemetry`);
    if (!isTelemetryEnabled || ci_info_1.isCI || !process.stdout.isTTY)
        return;
    core_1.Configuration.telemetry = new core_1.TelemetryManager(configuration, `puba9cdc10ec5790a2cf4969dd413a47270`);
    const PLUGIN_REGEX = /^@yarnpkg\/plugin-(.*)$/;
    for (const name of configuration.plugins.keys())
        if (pluginCommands_1.pluginCommands.has(name.match(PLUGIN_REGEX)?.[1] ?? ``))
            core_1.Configuration.telemetry?.reportPluginName(name);
    if (cli.binaryVersion) {
        core_1.Configuration.telemetry.reportVersion(cli.binaryVersion);
    }
}
function initCommands(cli, { configuration }) {
    for (const plugin of configuration.plugins.values()) {
        for (const command of plugin.commands || []) {
            cli.register(command);
        }
    }
}
async function run(cli, argv, { selfPath, pluginConfiguration }) {
    if (!validateNodejsVersion(cli))
        return 1;
    const configuration = await getCoreConfiguration({
        selfPath,
        pluginConfiguration,
    });
    const yarnPath = configuration.get(`yarnPath`);
    const ignorePath = configuration.get(`ignorePath`);
    if (yarnPath && !ignorePath)
        return runYarnPath(cli, argv, { yarnPath });
    delete process.env.YARN_IGNORE_PATH;
    const postCwdArgv = checkCwd(cli, argv);
    initTelemetry(cli, { configuration });
    initCommands(cli, { configuration });
    const command = cli.process(postCwdArgv, cli.defaultContext);
    if (!command.help)
        core_1.Configuration.telemetry?.reportCommandName(command.path.join(` `));
    return await cli.run(command, cli.defaultContext);
}
async function getCli({ cwd = fslib_1.ppath.cwd(), pluginConfiguration = (0, getPluginConfiguration_1.getPluginConfiguration)() } = {}) {
    const cli = getBaseCli({ cwd, pluginConfiguration });
    const configuration = await getCoreConfiguration({
        pluginConfiguration,
        selfPath: null,
    });
    initCommands(cli, { configuration });
    return cli;
}
exports.getCli = getCli;
async function runExit(argv, { cwd = fslib_1.ppath.cwd(), selfPath, pluginConfiguration }) {
    const cli = getBaseCli({ cwd, pluginConfiguration });
    try {
        process.exitCode = await run(cli, argv, { selfPath, pluginConfiguration });
    }
    catch (error) {
        clipanion_1.Cli.defaultContext.stdout.write(cli.error(error));
        process.exitCode = 1;
    }
    finally {
        await fslib_1.xfs.rmtempPromise();
    }
}
exports.runExit = runExit;
