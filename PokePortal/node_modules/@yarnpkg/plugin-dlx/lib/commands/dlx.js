"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const cli_1 = require("@yarnpkg/cli");
const core_1 = require("@yarnpkg/core");
const core_2 = require("@yarnpkg/core");
const fslib_1 = require("@yarnpkg/fslib");
const clipanion_1 = require("clipanion");
// eslint-disable-next-line arca/no-default-export
class DlxCommand extends cli_1.BaseCommand {
    constructor() {
        super(...arguments);
        this.packages = clipanion_1.Option.Array(`-p,--package`, {
            description: `The package(s) to install before running the command`,
        });
        this.quiet = clipanion_1.Option.Boolean(`-q,--quiet`, false, {
            description: `Only report critical errors instead of printing the full install logs`,
        });
        this.command = clipanion_1.Option.String();
        this.args = clipanion_1.Option.Proxy();
    }
    async execute() {
        // Disable telemetry to prevent each `dlx` call from counting as a project
        core_1.Configuration.telemetry = null;
        return await fslib_1.xfs.mktempPromise(async (baseDir) => {
            const tmpDir = fslib_1.ppath.join(baseDir, `dlx-${process.pid}`);
            await fslib_1.xfs.mkdirPromise(tmpDir);
            await fslib_1.xfs.writeFilePromise(fslib_1.ppath.join(tmpDir, `package.json`), `{}\n`);
            await fslib_1.xfs.writeFilePromise(fslib_1.ppath.join(tmpDir, `yarn.lock`), ``);
            const targetYarnrc = fslib_1.ppath.join(tmpDir, `.yarnrc.yml`);
            const projectCwd = await core_1.Configuration.findProjectCwd(this.context.cwd);
            // We set enableGlobalCache to true for dlx calls to speed it up but only if the
            // project it's run in has enableGlobalCache set to false, otherwise we risk running into
            // `Unable to locate pnpapi ... is controlled by multiple pnpapi instances` errors when
            // running something like `yarn dlx sb init`
            const enableGlobalCache = !(await core_1.Configuration.find(this.context.cwd, null, { strict: false })).get(`enableGlobalCache`);
            const dlxConfiguration = {
                enableGlobalCache,
                enableTelemetry: false,
                logFilters: [
                    // Don't warn if package extensions are unused in dlx projects
                    {
                        code: (0, core_1.stringifyMessageName)(core_1.MessageName.UNUSED_PACKAGE_EXTENSION),
                        level: core_2.formatUtils.LogLevel.Discard,
                    },
                ],
            };
            const sourceYarnrc = projectCwd !== null
                ? fslib_1.ppath.join(projectCwd, `.yarnrc.yml`)
                : null;
            if (sourceYarnrc !== null && fslib_1.xfs.existsSync(sourceYarnrc)) {
                await fslib_1.xfs.copyFilePromise(sourceYarnrc, targetYarnrc);
                await core_1.Configuration.updateConfiguration(tmpDir, current => {
                    const nextConfiguration = core_1.miscUtils.toMerged(current, dlxConfiguration);
                    if (Array.isArray(current.plugins)) {
                        nextConfiguration.plugins = current.plugins.map((plugin) => {
                            const sourcePath = typeof plugin === `string`
                                ? plugin
                                : plugin.path;
                            const remapPath = fslib_1.npath.isAbsolute(sourcePath)
                                ? sourcePath
                                : fslib_1.npath.resolve(fslib_1.npath.fromPortablePath(projectCwd), sourcePath);
                            if (typeof plugin === `string`) {
                                return remapPath;
                            }
                            else {
                                return { path: remapPath, spec: plugin.spec };
                            }
                        });
                    }
                    return nextConfiguration;
                });
            }
            else {
                await fslib_1.xfs.writeJsonPromise(targetYarnrc, dlxConfiguration);
            }
            const pkgs = this.packages ?? [this.command];
            let command = core_2.structUtils.parseDescriptor(this.command).name;
            const addExitCode = await this.cli.run([`add`, `--fixed`, `--`, ...pkgs], { cwd: tmpDir, quiet: this.quiet });
            if (addExitCode !== 0)
                return addExitCode;
            if (!this.quiet)
                this.context.stdout.write(`\n`);
            const configuration = await core_1.Configuration.find(tmpDir, this.context.plugins);
            const { project, workspace } = await core_1.Project.find(configuration, tmpDir);
            if (workspace === null)
                throw new cli_1.WorkspaceRequiredError(project.cwd, tmpDir);
            await project.restoreInstallState();
            const binaries = await core_2.scriptUtils.getWorkspaceAccessibleBinaries(workspace);
            if (binaries.has(command) === false && binaries.size === 1 && typeof this.packages === `undefined`)
                command = Array.from(binaries)[0][0];
            return await core_2.scriptUtils.executeWorkspaceAccessibleBinary(workspace, command, this.args, {
                packageAccessibleBinaries: binaries,
                cwd: this.context.cwd,
                stdin: this.context.stdin,
                stdout: this.context.stdout,
                stderr: this.context.stderr,
            });
        });
    }
}
DlxCommand.paths = [
    [`dlx`],
];
DlxCommand.usage = clipanion_1.Command.Usage({
    description: `run a package in a temporary environment`,
    details: `
      This command will install a package within a temporary environment, and run its binary script if it contains any. The binary will run within the current cwd.

      By default Yarn will download the package named \`command\`, but this can be changed through the use of the \`-p,--package\` flag which will instruct Yarn to still run the same command but from a different package.

      Using \`yarn dlx\` as a replacement of \`yarn add\` isn't recommended, as it makes your project non-deterministic (Yarn doesn't keep track of the packages installed through \`dlx\` - neither their name, nor their version).
    `,
    examples: [[
            `Use create-react-app to create a new React app`,
            `yarn dlx create-react-app ./my-app`,
        ], [
            `Install multiple packages for a single command`,
            `yarn dlx -p typescript -p ts-node ts-node --transpile-only -e "console.log('hello!')"`,
        ]],
});
exports.default = DlxCommand;
