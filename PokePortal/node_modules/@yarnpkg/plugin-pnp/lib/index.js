"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PnpLinker = exports.PnpInstaller = exports.quotePathIfNeeded = exports.getPnpPath = exports.pnpUtils = exports.jsInstallUtils = exports.UnplugCommand = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@yarnpkg/core");
const fslib_1 = require("@yarnpkg/fslib");
const url_1 = require("url");
const PnpLinker_1 = require("./PnpLinker");
const unplug_1 = tslib_1.__importDefault(require("./commands/unplug"));
exports.UnplugCommand = unplug_1.default;
const jsInstallUtils = tslib_1.__importStar(require("./jsInstallUtils"));
exports.jsInstallUtils = jsInstallUtils;
const pnpUtils = tslib_1.__importStar(require("./pnpUtils"));
exports.pnpUtils = pnpUtils;
const getPnpPath = (project) => {
    return {
        cjs: fslib_1.ppath.join(project.cwd, fslib_1.Filename.pnpCjs),
        data: fslib_1.ppath.join(project.cwd, fslib_1.Filename.pnpData),
        esmLoader: fslib_1.ppath.join(project.cwd, fslib_1.Filename.pnpEsmLoader),
    };
};
exports.getPnpPath = getPnpPath;
const quotePathIfNeeded = (path) => {
    return /\s/.test(path) ? JSON.stringify(path) : path;
};
exports.quotePathIfNeeded = quotePathIfNeeded;
async function setupScriptEnvironment(project, env, makePathWrapper) {
    // We still support .pnp.js files to improve multi-project compatibility.
    // TODO: Drop the question mark in the RegExp after .pnp.js files stop being used.
    // TODO: Support `-r` as an alias for `--require` (in all packages)
    const pnpRegularExpression = /\s*--require\s+\S*\.pnp\.c?js\s*/g;
    const esmLoaderExpression = /\s*--experimental-loader\s+\S*\.pnp\.loader\.mjs\s*/;
    const nodeOptions = (env.NODE_OPTIONS ?? ``)
        .replace(pnpRegularExpression, ` `)
        .replace(esmLoaderExpression, ` `)
        .trim();
    // We remove the PnP hook from NODE_OPTIONS because the process can have
    // NODE_OPTIONS set while changing linkers, which affects build scripts.
    if (project.configuration.get(`nodeLinker`) !== `pnp`) {
        env.NODE_OPTIONS = nodeOptions;
        return;
    }
    const pnpPath = (0, exports.getPnpPath)(project);
    let pnpRequire = `--require ${(0, exports.quotePathIfNeeded)(fslib_1.npath.fromPortablePath(pnpPath.cjs))}`;
    if (fslib_1.xfs.existsSync(pnpPath.esmLoader))
        pnpRequire = `${pnpRequire} --experimental-loader ${(0, url_1.pathToFileURL)(fslib_1.npath.fromPortablePath(pnpPath.esmLoader)).href}`;
    if (fslib_1.xfs.existsSync(pnpPath.cjs)) {
        env.NODE_OPTIONS = nodeOptions ? `${pnpRequire} ${nodeOptions}` : pnpRequire;
    }
}
async function populateYarnPaths(project, definePath) {
    const pnpPath = (0, exports.getPnpPath)(project);
    definePath(pnpPath.cjs);
    definePath(pnpPath.data);
    definePath(pnpPath.esmLoader);
    definePath(project.configuration.get(`pnpUnpluggedFolder`));
}
const plugin = {
    hooks: {
        populateYarnPaths,
        setupScriptEnvironment,
    },
    configuration: {
        nodeLinker: {
            description: `The linker used for installing Node packages, one of: "pnp", "pnpm", or "node-modules"`,
            type: core_1.SettingsType.STRING,
            default: `pnp`,
        },
        winLinkType: {
            description: `Whether Yarn should use Windows Junctions or symlinks when creating links on Windows.`,
            type: core_1.SettingsType.STRING,
            values: [
                core_1.WindowsLinkType.JUNCTIONS,
                core_1.WindowsLinkType.SYMLINKS,
            ],
            default: core_1.WindowsLinkType.JUNCTIONS,
        },
        pnpMode: {
            description: `If 'strict', generates standard PnP maps. If 'loose', merges them with the n_m resolution.`,
            type: core_1.SettingsType.STRING,
            default: `strict`,
        },
        pnpShebang: {
            description: `String to prepend to the generated PnP script`,
            type: core_1.SettingsType.STRING,
            default: `#!/usr/bin/env node`,
        },
        pnpIgnorePatterns: {
            description: `Array of glob patterns; files matching them will use the classic resolution`,
            type: core_1.SettingsType.STRING,
            default: [],
            isArray: true,
        },
        pnpEnableEsmLoader: {
            description: `If true, Yarn will generate an ESM loader (\`.pnp.loader.mjs\`). If this is not explicitly set Yarn tries to automatically detect whether ESM support is required.`,
            type: core_1.SettingsType.BOOLEAN,
            default: false,
        },
        pnpEnableInlining: {
            description: `If true, the PnP data will be inlined along with the generated loader`,
            type: core_1.SettingsType.BOOLEAN,
            default: true,
        },
        pnpFallbackMode: {
            description: `If true, the generated PnP loader will follow the top-level fallback rule`,
            type: core_1.SettingsType.STRING,
            default: `dependencies-only`,
        },
        pnpUnpluggedFolder: {
            description: `Folder where the unplugged packages must be stored`,
            type: core_1.SettingsType.ABSOLUTE_PATH,
            default: `./.yarn/unplugged`,
        },
    },
    linkers: [
        PnpLinker_1.PnpLinker,
    ],
    commands: [
        unplug_1.default,
    ],
};
var PnpLinker_2 = require("./PnpLinker");
Object.defineProperty(exports, "PnpInstaller", { enumerable: true, get: function () { return PnpLinker_2.PnpInstaller; } });
Object.defineProperty(exports, "PnpLinker", { enumerable: true, get: function () { return PnpLinker_2.PnpLinker; } });
// eslint-disable-next-line arca/no-default-export
exports.default = plugin;
