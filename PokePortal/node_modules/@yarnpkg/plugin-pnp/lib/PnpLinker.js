"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PnpInstaller = exports.PnpLinker = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@yarnpkg/core");
const core_2 = require("@yarnpkg/core");
const fslib_1 = require("@yarnpkg/fslib");
const pnp_1 = require("@yarnpkg/pnp");
const clipanion_1 = require("clipanion");
const index_1 = require("./index");
const jsInstallUtils = tslib_1.__importStar(require("./jsInstallUtils"));
const pnpUtils = tslib_1.__importStar(require("./pnpUtils"));
const FORCED_UNPLUG_PACKAGES = new Set([
    // Contains native binaries
    core_1.structUtils.makeIdent(null, `open`).identHash,
    core_1.structUtils.makeIdent(null, `opn`).identHash,
]);
class PnpLinker {
    constructor() {
        this.mode = `strict`;
        this.pnpCache = new Map();
    }
    getCustomDataKey() {
        return JSON.stringify({
            name: `PnpLinker`,
            version: 2,
        });
    }
    supportsPackage(pkg, opts) {
        return this.isEnabled(opts);
    }
    async findPackageLocation(locator, opts) {
        if (!this.isEnabled(opts))
            throw new Error(`Assertion failed: Expected the PnP linker to be enabled`);
        const pnpPath = (0, index_1.getPnpPath)(opts.project).cjs;
        if (!fslib_1.xfs.existsSync(pnpPath))
            throw new clipanion_1.UsageError(`The project in ${core_1.formatUtils.pretty(opts.project.configuration, `${opts.project.cwd}/package.json`, core_1.formatUtils.Type.PATH)} doesn't seem to have been installed - running an install there might help`);
        const pnpFile = core_1.miscUtils.getFactoryWithDefault(this.pnpCache, pnpPath, () => {
            return core_1.miscUtils.dynamicRequire(pnpPath, { cachingStrategy: core_1.miscUtils.CachingStrategy.FsTime });
        });
        const packageLocator = { name: core_1.structUtils.stringifyIdent(locator), reference: locator.reference };
        const packageInformation = pnpFile.getPackageInformation(packageLocator);
        if (!packageInformation)
            throw new clipanion_1.UsageError(`Couldn't find ${core_1.structUtils.prettyLocator(opts.project.configuration, locator)} in the currently installed PnP map - running an install might help`);
        return fslib_1.npath.toPortablePath(packageInformation.packageLocation);
    }
    async findPackageLocator(location, opts) {
        if (!this.isEnabled(opts))
            return null;
        const pnpPath = (0, index_1.getPnpPath)(opts.project).cjs;
        if (!fslib_1.xfs.existsSync(pnpPath))
            return null;
        const pnpFile = core_1.miscUtils.getFactoryWithDefault(this.pnpCache, pnpPath, () => {
            return core_1.miscUtils.dynamicRequire(pnpPath, { cachingStrategy: core_1.miscUtils.CachingStrategy.FsTime });
        });
        const locator = pnpFile.findPackageLocator(fslib_1.npath.fromPortablePath(location));
        if (!locator)
            return null;
        return core_1.structUtils.makeLocator(core_1.structUtils.parseIdent(locator.name), locator.reference);
    }
    makeInstaller(opts) {
        return new PnpInstaller(opts);
    }
    isEnabled(opts) {
        if (opts.project.configuration.get(`nodeLinker`) !== `pnp`)
            return false;
        if (opts.project.configuration.get(`pnpMode`) !== this.mode)
            return false;
        return true;
    }
}
exports.PnpLinker = PnpLinker;
class PnpInstaller {
    constructor(opts) {
        this.opts = opts;
        this.mode = `strict`;
        this.asyncActions = new core_1.miscUtils.AsyncActions(10);
        this.packageRegistry = new Map();
        this.virtualTemplates = new Map();
        this.isESMLoaderRequired = false;
        this.customData = {
            store: new Map(),
        };
        this.unpluggedPaths = new Set();
        this.opts = opts;
    }
    attachCustomData(customData) {
        this.customData = customData;
    }
    async installPackage(pkg, fetchResult, api) {
        const key1 = core_1.structUtils.stringifyIdent(pkg);
        const key2 = pkg.reference;
        const isWorkspace = !!this.opts.project.tryWorkspaceByLocator(pkg);
        const isVirtual = core_1.structUtils.isVirtualLocator(pkg);
        const hasVirtualInstances = 
        // Only packages with peer dependencies have virtual instances
        pkg.peerDependencies.size > 0 &&
            // Only packages with peer dependencies have virtual instances
            !isVirtual;
        const mayNeedToBeBuilt = 
        // Virtual instance templates don't need to be built, since they don't truly exist
        !hasVirtualInstances &&
            // Workspaces aren't built by the linkers; they are managed by the core itself
            !isWorkspace;
        const mayNeedToBeUnplugged = 
        // Virtual instance templates don't need to be unplugged, since they don't truly exist
        !hasVirtualInstances &&
            // We never need to unplug soft links, since we don't control them
            pkg.linkType !== core_2.LinkType.SOFT;
        let customPackageData;
        let dependencyMeta;
        if (mayNeedToBeBuilt || mayNeedToBeUnplugged) {
            const devirtualizedLocator = isVirtual ? core_1.structUtils.devirtualizeLocator(pkg) : pkg;
            customPackageData = this.customData.store.get(devirtualizedLocator.locatorHash);
            if (typeof customPackageData === `undefined`) {
                customPackageData = await extractCustomPackageData(fetchResult);
                if (pkg.linkType === core_2.LinkType.HARD) {
                    this.customData.store.set(devirtualizedLocator.locatorHash, customPackageData);
                }
            }
            if (customPackageData.manifest.type === `module`)
                this.isESMLoaderRequired = true;
            dependencyMeta = this.opts.project.getDependencyMeta(devirtualizedLocator, pkg.version);
        }
        const buildRequest = mayNeedToBeBuilt
            ? jsInstallUtils.extractBuildRequest(pkg, customPackageData, dependencyMeta, { configuration: this.opts.project.configuration })
            : null;
        const packageFs = mayNeedToBeUnplugged
            ? await this.unplugPackageIfNeeded(pkg, customPackageData, fetchResult, dependencyMeta, api)
            : fetchResult.packageFs;
        if (fslib_1.ppath.isAbsolute(fetchResult.prefixPath))
            throw new Error(`Assertion failed: Expected the prefix path (${fetchResult.prefixPath}) to be relative to the parent`);
        const packageRawLocation = fslib_1.ppath.resolve(packageFs.getRealPath(), fetchResult.prefixPath);
        const packageLocation = normalizeDirectoryPath(this.opts.project.cwd, packageRawLocation);
        const packageDependencies = new Map();
        const packagePeers = new Set();
        // Only virtual packages should have effective peer dependencies, but the
        // workspaces are a special case because the original packages are kept in
        // the dependency tree even after being virtualized; so in their case we
        // just ignore their declared peer dependencies.
        if (isVirtual) {
            for (const descriptor of pkg.peerDependencies.values()) {
                packageDependencies.set(core_1.structUtils.stringifyIdent(descriptor), null);
                packagePeers.add(core_1.structUtils.stringifyIdent(descriptor));
            }
            if (!isWorkspace) {
                const devirtualized = core_1.structUtils.devirtualizeLocator(pkg);
                this.virtualTemplates.set(devirtualized.locatorHash, {
                    location: normalizeDirectoryPath(this.opts.project.cwd, fslib_1.VirtualFS.resolveVirtual(packageRawLocation)),
                    locator: devirtualized,
                });
            }
        }
        core_1.miscUtils.getMapWithDefault(this.packageRegistry, key1).set(key2, {
            packageLocation,
            packageDependencies,
            packagePeers,
            linkType: pkg.linkType,
            discardFromLookup: fetchResult.discardFromLookup || false,
        });
        return {
            packageLocation: packageRawLocation,
            buildRequest,
        };
    }
    async attachInternalDependencies(locator, dependencies) {
        const packageInformation = this.getPackageInformation(locator);
        for (const [descriptor, locator] of dependencies) {
            const target = !core_1.structUtils.areIdentsEqual(descriptor, locator)
                ? [core_1.structUtils.stringifyIdent(locator), locator.reference]
                : locator.reference;
            packageInformation.packageDependencies.set(core_1.structUtils.stringifyIdent(descriptor), target);
        }
    }
    async attachExternalDependents(locator, dependentPaths) {
        for (const dependentPath of dependentPaths) {
            const packageInformation = this.getDiskInformation(dependentPath);
            packageInformation.packageDependencies.set(core_1.structUtils.stringifyIdent(locator), locator.reference);
        }
    }
    async finalizeInstall() {
        if (this.opts.project.configuration.get(`pnpMode`) !== this.mode)
            return undefined;
        const pnpPath = (0, index_1.getPnpPath)(this.opts.project);
        if (!this.isEsmEnabled())
            await fslib_1.xfs.removePromise(pnpPath.esmLoader);
        if (this.opts.project.configuration.get(`nodeLinker`) !== `pnp`) {
            await fslib_1.xfs.removePromise(pnpPath.cjs);
            await fslib_1.xfs.removePromise(pnpPath.data);
            await fslib_1.xfs.removePromise(pnpPath.esmLoader);
            await fslib_1.xfs.removePromise(this.opts.project.configuration.get(`pnpUnpluggedFolder`));
            return undefined;
        }
        for (const { locator, location } of this.virtualTemplates.values()) {
            core_1.miscUtils.getMapWithDefault(this.packageRegistry, core_1.structUtils.stringifyIdent(locator)).set(locator.reference, {
                packageLocation: location,
                packageDependencies: new Map(),
                packagePeers: new Set(),
                linkType: core_2.LinkType.SOFT,
                discardFromLookup: false,
            });
        }
        this.packageRegistry.set(null, new Map([
            [null, this.getPackageInformation(this.opts.project.topLevelWorkspace.anchoredLocator)],
        ]));
        const pnpFallbackMode = this.opts.project.configuration.get(`pnpFallbackMode`);
        const dependencyTreeRoots = this.opts.project.workspaces.map(({ anchoredLocator }) => ({ name: core_1.structUtils.stringifyIdent(anchoredLocator), reference: anchoredLocator.reference }));
        const enableTopLevelFallback = pnpFallbackMode !== `none`;
        const fallbackExclusionList = [];
        const fallbackPool = new Map();
        const ignorePattern = core_1.miscUtils.buildIgnorePattern([`.yarn/sdks/**`, ...this.opts.project.configuration.get(`pnpIgnorePatterns`)]);
        const packageRegistry = this.packageRegistry;
        const shebang = this.opts.project.configuration.get(`pnpShebang`);
        if (pnpFallbackMode === `dependencies-only`)
            for (const pkg of this.opts.project.storedPackages.values())
                if (this.opts.project.tryWorkspaceByLocator(pkg))
                    fallbackExclusionList.push({ name: core_1.structUtils.stringifyIdent(pkg), reference: pkg.reference });
        await this.asyncActions.wait();
        await this.finalizeInstallWithPnp({
            dependencyTreeRoots,
            enableTopLevelFallback,
            fallbackExclusionList,
            fallbackPool,
            ignorePattern,
            packageRegistry,
            shebang,
        });
        return {
            customData: this.customData,
        };
    }
    async transformPnpSettings(pnpSettings) {
        // Nothing to transform
    }
    isEsmEnabled() {
        if (this.opts.project.configuration.sources.has(`pnpEnableEsmLoader`))
            return this.opts.project.configuration.get(`pnpEnableEsmLoader`);
        if (this.isESMLoaderRequired)
            return true;
        for (const workspace of this.opts.project.workspaces) {
            if (workspace.manifest.type === `module`) {
                return true;
            }
        }
        return false;
    }
    async finalizeInstallWithPnp(pnpSettings) {
        const pnpPath = (0, index_1.getPnpPath)(this.opts.project);
        const nodeModules = await this.locateNodeModules(pnpSettings.ignorePattern);
        if (nodeModules.length > 0) {
            this.opts.report.reportWarning(core_2.MessageName.DANGEROUS_NODE_MODULES, `One or more node_modules have been detected and will be removed. This operation may take some time.`);
            for (const nodeModulesPath of nodeModules) {
                await fslib_1.xfs.removePromise(nodeModulesPath);
            }
        }
        await this.transformPnpSettings(pnpSettings);
        if (this.opts.project.configuration.get(`pnpEnableInlining`)) {
            const loaderFile = (0, pnp_1.generateInlinedScript)(pnpSettings);
            await fslib_1.xfs.changeFilePromise(pnpPath.cjs, loaderFile, {
                automaticNewlines: true,
                mode: 0o755,
            });
            await fslib_1.xfs.removePromise(pnpPath.data);
        }
        else {
            const { dataFile, loaderFile } = (0, pnp_1.generateSplitScript)(pnpSettings);
            await fslib_1.xfs.changeFilePromise(pnpPath.cjs, loaderFile, {
                automaticNewlines: true,
                mode: 0o755,
            });
            await fslib_1.xfs.changeFilePromise(pnpPath.data, dataFile, {
                automaticNewlines: true,
                mode: 0o644,
            });
        }
        if (this.isEsmEnabled()) {
            this.opts.report.reportWarning(core_2.MessageName.UNNAMED, `ESM support for PnP uses the experimental loader API and is therefore experimental`);
            await fslib_1.xfs.changeFilePromise(pnpPath.esmLoader, (0, pnp_1.getESMLoaderTemplate)(), {
                automaticNewlines: true,
                mode: 0o644,
            });
        }
        const pnpUnpluggedFolder = this.opts.project.configuration.get(`pnpUnpluggedFolder`);
        if (this.unpluggedPaths.size === 0) {
            await fslib_1.xfs.removePromise(pnpUnpluggedFolder);
        }
        else {
            for (const entry of await fslib_1.xfs.readdirPromise(pnpUnpluggedFolder)) {
                const unpluggedPath = fslib_1.ppath.resolve(pnpUnpluggedFolder, entry);
                if (!this.unpluggedPaths.has(unpluggedPath)) {
                    await fslib_1.xfs.removePromise(unpluggedPath);
                }
            }
        }
    }
    async locateNodeModules(ignorePattern) {
        const nodeModules = [];
        const ignoreRegExp = ignorePattern ? new RegExp(ignorePattern) : null;
        for (const workspace of this.opts.project.workspaces) {
            const nodeModulesPath = fslib_1.ppath.join(workspace.cwd, `node_modules`);
            if (ignoreRegExp && ignoreRegExp.test(fslib_1.ppath.relative(this.opts.project.cwd, workspace.cwd)) || !fslib_1.xfs.existsSync(nodeModulesPath))
                continue;
            const directoryListing = await fslib_1.xfs.readdirPromise(nodeModulesPath, {
                withFileTypes: true,
            });
            const nonCacheEntries = directoryListing.filter(entry => {
                return !entry.isDirectory() || entry.name === `.bin` || !entry.name.startsWith(`.`);
            });
            if (nonCacheEntries.length === directoryListing.length) {
                nodeModules.push(nodeModulesPath);
            }
            else {
                for (const entry of nonCacheEntries) {
                    nodeModules.push(fslib_1.ppath.join(nodeModulesPath, entry.name));
                }
            }
        }
        return nodeModules;
    }
    async unplugPackageIfNeeded(pkg, customPackageData, fetchResult, dependencyMeta, api) {
        if (this.shouldBeUnplugged(pkg, customPackageData, dependencyMeta)) {
            return this.unplugPackage(pkg, fetchResult, api);
        }
        else {
            return fetchResult.packageFs;
        }
    }
    shouldBeUnplugged(pkg, customPackageData, dependencyMeta) {
        if (typeof dependencyMeta.unplugged !== `undefined`)
            return dependencyMeta.unplugged;
        if (FORCED_UNPLUG_PACKAGES.has(pkg.identHash))
            return true;
        if (pkg.conditions != null)
            return true;
        if (customPackageData.manifest.preferUnplugged !== null)
            return customPackageData.manifest.preferUnplugged;
        const buildRequest = jsInstallUtils.extractBuildRequest(pkg, customPackageData, dependencyMeta, { configuration: this.opts.project.configuration });
        if (buildRequest?.skipped === false || customPackageData.misc.extractHint)
            return true;
        return false;
    }
    async unplugPackage(locator, fetchResult, api) {
        const unplugPath = pnpUtils.getUnpluggedPath(locator, { configuration: this.opts.project.configuration });
        if (this.opts.project.disabledLocators.has(locator.locatorHash))
            return new fslib_1.AliasFS(unplugPath, { baseFs: fetchResult.packageFs, pathUtils: fslib_1.ppath });
        this.unpluggedPaths.add(unplugPath);
        api.holdFetchResult(this.asyncActions.set(locator.locatorHash, async () => {
            const readyFile = fslib_1.ppath.join(unplugPath, fetchResult.prefixPath, `.ready`);
            if (await fslib_1.xfs.existsPromise(readyFile))
                return;
            // Delete any build state for the locator so it can run anew, this allows users
            // to remove `.yarn/unplugged` and have the builds run again
            this.opts.project.storedBuildState.delete(locator.locatorHash);
            await fslib_1.xfs.mkdirPromise(unplugPath, { recursive: true });
            await fslib_1.xfs.copyPromise(unplugPath, fslib_1.PortablePath.dot, { baseFs: fetchResult.packageFs, overwrite: false });
            await fslib_1.xfs.writeFilePromise(readyFile, ``);
        }));
        return new fslib_1.CwdFS(unplugPath);
    }
    getPackageInformation(locator) {
        const key1 = core_1.structUtils.stringifyIdent(locator);
        const key2 = locator.reference;
        const packageInformationStore = this.packageRegistry.get(key1);
        if (!packageInformationStore)
            throw new Error(`Assertion failed: The package information store should have been available (for ${core_1.structUtils.prettyIdent(this.opts.project.configuration, locator)})`);
        const packageInformation = packageInformationStore.get(key2);
        if (!packageInformation)
            throw new Error(`Assertion failed: The package information should have been available (for ${core_1.structUtils.prettyLocator(this.opts.project.configuration, locator)})`);
        return packageInformation;
    }
    getDiskInformation(path) {
        const packageStore = core_1.miscUtils.getMapWithDefault(this.packageRegistry, `@@disk`);
        const normalizedPath = normalizeDirectoryPath(this.opts.project.cwd, path);
        return core_1.miscUtils.getFactoryWithDefault(packageStore, normalizedPath, () => ({
            packageLocation: normalizedPath,
            packageDependencies: new Map(),
            packagePeers: new Set(),
            linkType: core_2.LinkType.SOFT,
            discardFromLookup: false,
        }));
    }
}
exports.PnpInstaller = PnpInstaller;
function normalizeDirectoryPath(root, folder) {
    let relativeFolder = fslib_1.ppath.relative(root, folder);
    if (!relativeFolder.match(/^\.{0,2}\//))
        // Don't use ppath.join here, it ignores the `.`
        relativeFolder = `./${relativeFolder}`;
    return relativeFolder.replace(/\/?$/, `/`);
}
async function extractCustomPackageData(fetchResult) {
    const manifest = await core_2.Manifest.tryFind(fetchResult.prefixPath, { baseFs: fetchResult.packageFs }) ?? new core_2.Manifest();
    const preservedScripts = new Set([`preinstall`, `install`, `postinstall`]);
    for (const scriptName of manifest.scripts.keys())
        if (!preservedScripts.has(scriptName))
            manifest.scripts.delete(scriptName);
    return {
        manifest: {
            scripts: manifest.scripts,
            preferUnplugged: manifest.preferUnplugged,
            type: manifest.type,
        },
        misc: {
            extractHint: jsInstallUtils.getExtractHint(fetchResult),
            hasBindingGyp: jsInstallUtils.hasBindingGyp(fetchResult),
        },
    };
}
