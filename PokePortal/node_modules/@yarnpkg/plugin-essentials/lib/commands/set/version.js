"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.setVersion = exports.resolveTag = exports.resolveRange = void 0;
const tslib_1 = require("tslib");
const cli_1 = require("@yarnpkg/cli");
const core_1 = require("@yarnpkg/core");
const core_2 = require("@yarnpkg/core");
const fslib_1 = require("@yarnpkg/fslib");
const clipanion_1 = require("clipanion");
const semver_1 = tslib_1.__importDefault(require("semver"));
// eslint-disable-next-line arca/no-default-export
class SetVersionCommand extends cli_1.BaseCommand {
    constructor() {
        super(...arguments);
        this.useYarnPath = clipanion_1.Option.Boolean(`--yarn-path`, {
            description: `Set the yarnPath setting even if the version can be accessed by Corepack`,
        });
        this.onlyIfNeeded = clipanion_1.Option.Boolean(`--only-if-needed`, false, {
            description: `Only lock the Yarn version if it isn't already locked`,
        });
        this.version = clipanion_1.Option.String();
    }
    async execute() {
        const configuration = await core_1.Configuration.find(this.context.cwd, this.context.plugins);
        if (this.onlyIfNeeded && configuration.get(`yarnPath`)) {
            const yarnPathSource = configuration.sources.get(`yarnPath`);
            if (!yarnPathSource)
                throw new Error(`Assertion failed: Expected 'yarnPath' to have a source`);
            const projectCwd = configuration.projectCwd ?? configuration.startingCwd;
            if (fslib_1.ppath.contains(projectCwd, yarnPathSource)) {
                return 0;
            }
        }
        const getBundlePath = () => {
            if (typeof core_1.YarnVersion === `undefined`)
                throw new clipanion_1.UsageError(`The --install flag can only be used without explicit version specifier from the Yarn CLI`);
            return `file://${process.argv[1]}`;
        };
        let bundleRef;
        const getRef = (url, version) => {
            return { version, url: url.replace(/\{\}/g, version) };
        };
        if (this.version === `self`)
            bundleRef = { url: getBundlePath(), version: core_1.YarnVersion ?? `self` };
        else if (this.version === `latest` || this.version === `berry` || this.version === `stable`)
            bundleRef = getRef(`https://repo.yarnpkg.com/{}/packages/yarnpkg-cli/bin/yarn.js`, await resolveTag(configuration, `stable`));
        else if (this.version === `canary`)
            bundleRef = getRef(`https://repo.yarnpkg.com/{}/packages/yarnpkg-cli/bin/yarn.js`, await resolveTag(configuration, `canary`));
        else if (this.version === `classic`)
            bundleRef = { url: `https://classic.yarnpkg.com/latest.js`, version: `classic` };
        else if (this.version.match(/^https?:/))
            bundleRef = { url: this.version, version: `remote` };
        else if (this.version.match(/^\.{0,2}[\\/]/) || fslib_1.npath.isAbsolute(this.version))
            bundleRef = { url: `file://${fslib_1.ppath.resolve(fslib_1.npath.toPortablePath(this.version))}`, version: `file` };
        else if (core_2.semverUtils.satisfiesWithPrereleases(this.version, `>=2.0.0`))
            bundleRef = getRef(`https://repo.yarnpkg.com/{}/packages/yarnpkg-cli/bin/yarn.js`, this.version);
        else if (core_2.semverUtils.satisfiesWithPrereleases(this.version, `^0.x || ^1.x`))
            bundleRef = getRef(`https://github.com/yarnpkg/yarn/releases/download/v{}/yarn-{}.js`, this.version);
        else if (core_2.semverUtils.validRange(this.version))
            bundleRef = getRef(`https://repo.yarnpkg.com/{}/packages/yarnpkg-cli/bin/yarn.js`, await resolveRange(configuration, this.version));
        else
            throw new clipanion_1.UsageError(`Invalid version descriptor "${this.version}"`);
        const report = await core_1.StreamReport.start({
            configuration,
            stdout: this.context.stdout,
            includeLogs: !this.context.quiet,
        }, async (report) => {
            const fetchBuffer = async () => {
                const filePrefix = `file://`;
                if (bundleRef.url.startsWith(filePrefix)) {
                    report.reportInfo(core_1.MessageName.UNNAMED, `Retrieving ${core_2.formatUtils.pretty(configuration, bundleRef.url, core_2.formatUtils.Type.PATH)}`);
                    return await fslib_1.xfs.readFilePromise(bundleRef.url.slice(filePrefix.length));
                }
                else {
                    report.reportInfo(core_1.MessageName.UNNAMED, `Downloading ${core_2.formatUtils.pretty(configuration, bundleRef.url, core_2.formatUtils.Type.URL)}`);
                    return await core_2.httpUtils.get(bundleRef.url, { configuration });
                }
            };
            await setVersion(configuration, bundleRef.version, fetchBuffer, { report, useYarnPath: this.useYarnPath });
        });
        return report.exitCode();
    }
}
SetVersionCommand.paths = [
    [`set`, `version`],
];
SetVersionCommand.usage = clipanion_1.Command.Usage({
    description: `lock the Yarn version used by the project`,
    details: `
      This command will set a specific release of Yarn to be used by Corepack: https://nodejs.org/api/corepack.html.

      By default it only will set the \`packageManager\` field at the root of your project, but if the referenced release cannot be represented this way, if you already have \`yarnPath\` configured, or if you set the \`--yarn-path\` command line flag, then the release will also be downloaded from the Yarn GitHub repository, stored inside your project, and referenced via the \`yarnPath\` settings from your project \`.yarnrc.yml\` file.

      A very good use case for this command is to enforce the version of Yarn used by any single member of your team inside the same project - by doing this you ensure that you have control over Yarn upgrades and downgrades (including on your deployment servers), and get rid of most of the headaches related to someone using a slightly different version and getting different behavior.

      The version specifier can be:

      - a tag:
        - \`latest\` / \`berry\` / \`stable\` -> the most recent stable berry (\`>=2.0.0\`) release
        - \`canary\` -> the most recent canary (release candidate) berry (\`>=2.0.0\`) release
        - \`classic\` -> the most recent classic (\`^0.x || ^1.x\`) release

      - a semver range (e.g. \`2.x\`) -> the most recent version satisfying the range (limited to berry releases)

      - a semver version (e.g. \`2.4.1\`, \`1.22.1\`)

      - a local file referenced through either a relative or absolute path

      - \`self\` -> the version used to invoke the command
    `,
    examples: [[
            `Download the latest release from the Yarn repository`,
            `$0 set version latest`,
        ], [
            `Download the latest canary release from the Yarn repository`,
            `$0 set version canary`,
        ], [
            `Download the latest classic release from the Yarn repository`,
            `$0 set version classic`,
        ], [
            `Download the most recent Yarn 3 build`,
            `$0 set version 3.x`,
        ], [
            `Download a specific Yarn 2 build`,
            `$0 set version 2.0.0-rc.30`,
        ], [
            `Switch back to a specific Yarn 1 release`,
            `$0 set version 1.22.1`,
        ], [
            `Use a release from the local filesystem`,
            `$0 set version ./yarn.cjs`,
        ], [
            `Use a release from a URL`,
            `$0 set version https://repo.yarnpkg.com/3.1.0/packages/yarnpkg-cli/bin/yarn.js`,
        ], [
            `Download the version used to invoke the command`,
            `$0 set version self`,
        ]],
});
exports.default = SetVersionCommand;
async function resolveRange(configuration, request) {
    const data = await core_2.httpUtils.get(`https://repo.yarnpkg.com/tags`, { configuration, jsonResponse: true });
    const candidates = data.tags.filter(version => core_2.semverUtils.satisfiesWithPrereleases(version, request));
    if (candidates.length === 0)
        throw new clipanion_1.UsageError(`No matching release found for range ${core_2.formatUtils.pretty(configuration, request, core_2.formatUtils.Type.RANGE)}.`);
    // The tags on the website are sorted by semver descending
    return candidates[0];
}
exports.resolveRange = resolveRange;
async function resolveTag(configuration, request) {
    const data = await core_2.httpUtils.get(`https://repo.yarnpkg.com/tags`, { configuration, jsonResponse: true });
    if (!data.latest[request])
        throw new clipanion_1.UsageError(`Tag ${core_2.formatUtils.pretty(configuration, request, core_2.formatUtils.Type.RANGE)} not found`);
    return data.latest[request];
}
exports.resolveTag = resolveTag;
async function setVersion(configuration, bundleVersion, fetchBuffer, { report, useYarnPath }) {
    let bundleBuffer;
    const ensureBuffer = async () => {
        if (typeof bundleBuffer === `undefined`)
            bundleBuffer = await fetchBuffer();
        return bundleBuffer;
    };
    if (bundleVersion === null) {
        const bundleBuffer = await ensureBuffer();
        await fslib_1.xfs.mktempPromise(async (tmpDir) => {
            const temporaryPath = fslib_1.ppath.join(tmpDir, `yarn.cjs`);
            await fslib_1.xfs.writeFilePromise(temporaryPath, bundleBuffer);
            const { stdout } = await core_2.execUtils.execvp(process.execPath, [fslib_1.npath.fromPortablePath(temporaryPath), `--version`], {
                cwd: tmpDir,
                env: { ...configuration.env, YARN_IGNORE_PATH: `1` },
            });
            bundleVersion = stdout.trim();
            if (!semver_1.default.valid(bundleVersion)) {
                throw new Error(`Invalid semver version. ${core_2.formatUtils.pretty(configuration, `yarn --version`, core_2.formatUtils.Type.CODE)} returned:\n${bundleVersion}`);
            }
        });
    }
    const projectCwd = configuration.projectCwd ?? configuration.startingCwd;
    const releaseFolder = fslib_1.ppath.resolve(projectCwd, `.yarn/releases`);
    const absolutePath = fslib_1.ppath.resolve(releaseFolder, `yarn-${bundleVersion}.cjs`);
    const displayPath = fslib_1.ppath.relative(configuration.startingCwd, absolutePath);
    const isTaggedYarnVersion = core_2.miscUtils.isTaggedYarnVersion(bundleVersion);
    const yarnPath = configuration.get(`yarnPath`);
    const absolutelyMustUseYarnPath = !isTaggedYarnVersion;
    let probablyShouldUseYarnPath = absolutelyMustUseYarnPath || !!yarnPath || !!useYarnPath;
    if (useYarnPath === false) {
        if (absolutelyMustUseYarnPath)
            throw new core_1.ReportError(core_1.MessageName.UNNAMED, `You explicitly opted out of yarnPath usage in your command line, but the version you specified cannot be represented by Corepack`);
        probablyShouldUseYarnPath = false;
    }
    else if (!probablyShouldUseYarnPath && !process.env.COREPACK_ROOT) {
        report.reportWarning(core_1.MessageName.UNNAMED, `You don't seem to have ${core_2.formatUtils.applyHyperlink(configuration, `Corepack`, `https://nodejs.org/api/corepack.html`)} enabled; we'll have to rely on ${core_2.formatUtils.applyHyperlink(configuration, `yarnPath`, `https://yarnpkg.com/configuration/yarnrc#yarnPath`)} instead`);
        probablyShouldUseYarnPath = true;
    }
    if (probablyShouldUseYarnPath) {
        const bundleBuffer = await ensureBuffer();
        report.reportInfo(core_1.MessageName.UNNAMED, `Saving the new release in ${core_2.formatUtils.pretty(configuration, displayPath, `magenta`)}`);
        await fslib_1.xfs.removePromise(fslib_1.ppath.dirname(absolutePath));
        await fslib_1.xfs.mkdirPromise(fslib_1.ppath.dirname(absolutePath), { recursive: true });
        await fslib_1.xfs.writeFilePromise(absolutePath, bundleBuffer, { mode: 0o755 });
        await core_1.Configuration.updateConfiguration(projectCwd, {
            yarnPath: fslib_1.ppath.relative(projectCwd, absolutePath),
        });
    }
    else {
        await fslib_1.xfs.removePromise(fslib_1.ppath.dirname(absolutePath));
        await core_1.Configuration.updateConfiguration(projectCwd, {
            yarnPath: core_1.Configuration.deleteProperty,
        });
    }
    const manifest = (await core_1.Manifest.tryFind(projectCwd)) || new core_1.Manifest();
    manifest.packageManager = `yarn@${isTaggedYarnVersion
        ? bundleVersion
        // If the version isn't tagged, we use the latest stable version as the wrapper
        : await resolveTag(configuration, `stable`)}`;
    const data = {};
    manifest.exportTo(data);
    const path = fslib_1.ppath.join(projectCwd, core_1.Manifest.fileName);
    const content = `${JSON.stringify(data, null, manifest.indent)}\n`;
    await fslib_1.xfs.changeFilePromise(path, content, {
        automaticNewlines: true,
    });
    return {
        bundleVersion: bundleVersion,
    };
}
exports.setVersion = setVersion;
