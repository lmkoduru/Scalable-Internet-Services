"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildAndSavePlugin = void 0;
const cli_1 = require("@yarnpkg/cli");
const core_1 = require("@yarnpkg/core");
const core_2 = require("@yarnpkg/core");
const fslib_1 = require("@yarnpkg/fslib");
const clipanion_1 = require("clipanion");
const os_1 = require("os");
const sources_1 = require("../../set/version/sources");
const import_1 = require("../import");
const list_1 = require("../list");
const buildWorkflow = ({ pluginName, noMinify }, target) => [
    [`yarn`, `build:${pluginName}`, ...noMinify ? [`--no-minify`] : [], `|`],
];
// eslint-disable-next-line arca/no-default-export
class PluginImportSourcesCommand extends cli_1.BaseCommand {
    constructor() {
        super(...arguments);
        this.installPath = clipanion_1.Option.String(`--path`, {
            description: `The path where the repository should be cloned to`,
        });
        this.repository = clipanion_1.Option.String(`--repository`, `https://github.com/yarnpkg/berry.git`, {
            description: `The repository that should be cloned`,
        });
        this.branch = clipanion_1.Option.String(`--branch`, `master`, {
            description: `The branch of the repository that should be cloned`,
        });
        this.noMinify = clipanion_1.Option.Boolean(`--no-minify`, false, {
            description: `Build a plugin for development (debugging) - non-minified and non-mangled`,
        });
        this.force = clipanion_1.Option.Boolean(`-f,--force`, false, {
            description: `Always clone the repository instead of trying to fetch the latest commits`,
        });
        this.name = clipanion_1.Option.String();
    }
    async execute() {
        const configuration = await core_2.Configuration.find(this.context.cwd, this.context.plugins);
        const target = typeof this.installPath !== `undefined`
            ? fslib_1.ppath.resolve(this.context.cwd, fslib_1.npath.toPortablePath(this.installPath))
            : fslib_1.ppath.resolve(fslib_1.npath.toPortablePath((0, os_1.tmpdir)()), `yarnpkg-sources`, core_1.hashUtils.makeHash(this.repository).slice(0, 6));
        const report = await core_2.StreamReport.start({
            configuration,
            stdout: this.context.stdout,
        }, async (report) => {
            const { project } = await core_2.Project.find(configuration, this.context.cwd);
            const ident = core_1.structUtils.parseIdent(this.name.replace(/^((@yarnpkg\/)?plugin-)?/, `@yarnpkg/plugin-`));
            const identStr = core_1.structUtils.stringifyIdent(ident);
            const data = await (0, list_1.getAvailablePlugins)(configuration, core_1.YarnVersion);
            if (!Object.hasOwn(data, identStr))
                throw new core_2.ReportError(core_2.MessageName.PLUGIN_NAME_NOT_FOUND, `Couldn't find a plugin named "${identStr}" on the remote registry. Note that only the plugins referenced on our website (https://github.com/yarnpkg/berry/blob/master/plugins.yml) can be built and imported from sources.`);
            const pluginSpec = identStr;
            await (0, sources_1.prepareRepo)(this, { configuration, report, target });
            await buildAndSavePlugin(pluginSpec, this, { project, report, target });
        });
        return report.exitCode();
    }
}
PluginImportSourcesCommand.paths = [
    [`plugin`, `import`, `from`, `sources`],
];
PluginImportSourcesCommand.usage = clipanion_1.Command.Usage({
    category: `Plugin-related commands`,
    description: `build a plugin from sources`,
    details: `
      This command clones the Yarn repository into a temporary folder, builds the specified contrib plugin and updates the configuration to reference it in further CLI invocations.

      The plugins can be referenced by their short name if sourced from the official Yarn repository.
    `,
    examples: [[
            `Build and activate the "@yarnpkg/plugin-exec" plugin`,
            `$0 plugin import from sources @yarnpkg/plugin-exec`,
        ], [
            `Build and activate the "@yarnpkg/plugin-exec" plugin (shorthand)`,
            `$0 plugin import from sources exec`,
        ]],
});
exports.default = PluginImportSourcesCommand;
async function buildAndSavePlugin(pluginSpec, { context, noMinify }, { project, report, target }) {
    const pluginName = pluginSpec.replace(/@yarnpkg\//, ``);
    const { configuration } = project;
    report.reportSeparator();
    report.reportInfo(core_2.MessageName.UNNAMED, `Building a fresh ${pluginName}`);
    report.reportSeparator();
    await (0, sources_1.runWorkflow)(buildWorkflow({
        pluginName,
        noMinify,
    }, target), { configuration, context, target });
    report.reportSeparator();
    const pluginPath = fslib_1.ppath.resolve(target, `packages/${pluginName}/bundles/${pluginSpec}.js`);
    const pluginBuffer = await fslib_1.xfs.readFilePromise(pluginPath);
    await (0, import_1.savePlugin)(pluginSpec, pluginBuffer, { project, report });
}
exports.buildAndSavePlugin = buildAndSavePlugin;
