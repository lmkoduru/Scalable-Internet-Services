"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.savePlugin = void 0;
const tslib_1 = require("tslib");
const cli_1 = require("@yarnpkg/cli");
const core_1 = require("@yarnpkg/core");
const core_2 = require("@yarnpkg/core");
const fslib_1 = require("@yarnpkg/fslib");
const clipanion_1 = require("clipanion");
const semver_1 = tslib_1.__importDefault(require("semver"));
const url_1 = require("url");
const vm_1 = require("vm");
const list_1 = require("./list");
// eslint-disable-next-line arca/no-default-export
class PluginImportCommand extends cli_1.BaseCommand {
    constructor() {
        super(...arguments);
        this.name = clipanion_1.Option.String();
        this.checksum = clipanion_1.Option.Boolean(`--checksum`, true, {
            description: `Whether to care if this plugin is modified`,
        });
    }
    async execute() {
        const configuration = await core_1.Configuration.find(this.context.cwd, this.context.plugins);
        const report = await core_1.StreamReport.start({
            configuration,
            stdout: this.context.stdout,
        }, async (report) => {
            const { project } = await core_1.Project.find(configuration, this.context.cwd);
            let pluginSpec;
            let pluginBuffer;
            if (this.name.match(/^\.{0,2}[\\/]/) || fslib_1.npath.isAbsolute(this.name)) {
                const candidatePath = fslib_1.ppath.resolve(this.context.cwd, fslib_1.npath.toPortablePath(this.name));
                report.reportInfo(core_1.MessageName.UNNAMED, `Reading ${core_2.formatUtils.pretty(configuration, candidatePath, core_2.formatUtils.Type.PATH)}`);
                pluginSpec = fslib_1.ppath.relative(project.cwd, candidatePath);
                pluginBuffer = await fslib_1.xfs.readFilePromise(candidatePath);
            }
            else {
                let pluginUrl;
                if (this.name.match(/^https?:/)) {
                    try {
                        new url_1.URL(this.name);
                    }
                    catch {
                        throw new core_1.ReportError(core_1.MessageName.INVALID_PLUGIN_REFERENCE, `Plugin specifier "${this.name}" is neither a plugin name nor a valid url`);
                    }
                    pluginSpec = this.name;
                    pluginUrl = this.name;
                }
                else {
                    const locator = core_2.structUtils.parseLocator(this.name.replace(/^((@yarnpkg\/)?plugin-)?/, `@yarnpkg/plugin-`));
                    if (locator.reference !== `unknown` && !semver_1.default.valid(locator.reference))
                        throw new core_1.ReportError(core_1.MessageName.UNNAMED, `Official plugins only accept strict version references. Use an explicit URL if you wish to download them from another location.`);
                    const identStr = core_2.structUtils.stringifyIdent(locator);
                    const data = await (0, list_1.getAvailablePlugins)(configuration, core_2.YarnVersion);
                    if (!Object.hasOwn(data, identStr)) {
                        let message = `Couldn't find a plugin named ${core_2.structUtils.prettyIdent(configuration, locator)} on the remote registry.\n`;
                        if (configuration.plugins.has(identStr))
                            message += `A plugin named ${core_2.structUtils.prettyIdent(configuration, locator)} is already installed; possibly attempting to import a built-in plugin.`;
                        else
                            message += `Note that only the plugins referenced on our website (${core_2.formatUtils.pretty(configuration, `https://github.com/yarnpkg/berry/blob/master/plugins.yml`, core_2.formatUtils.Type.URL)}) can be referenced by their name; any other plugin will have to be referenced through its public url (for example ${core_2.formatUtils.pretty(configuration, `https://github.com/yarnpkg/berry/raw/master/packages/plugin-typescript/bin/%40yarnpkg/plugin-typescript.js`, core_2.formatUtils.Type.URL)}).`;
                        throw new core_1.ReportError(core_1.MessageName.PLUGIN_NAME_NOT_FOUND, message);
                    }
                    pluginSpec = identStr;
                    pluginUrl = data[identStr].url;
                    if (locator.reference !== `unknown`) {
                        pluginUrl = pluginUrl.replace(/\/master\//, `/${identStr}/${locator.reference}/`);
                    }
                    else if (core_2.YarnVersion !== null) {
                        pluginUrl = pluginUrl.replace(/\/master\//, `/@yarnpkg/cli/${core_2.YarnVersion}/`);
                    }
                }
                report.reportInfo(core_1.MessageName.UNNAMED, `Downloading ${core_2.formatUtils.pretty(configuration, pluginUrl, `green`)}`);
                pluginBuffer = await core_2.httpUtils.get(pluginUrl, { configuration });
            }
            await savePlugin(pluginSpec, pluginBuffer, { checksum: this.checksum, project, report });
        });
        return report.exitCode();
    }
}
PluginImportCommand.paths = [
    [`plugin`, `import`],
];
PluginImportCommand.usage = clipanion_1.Command.Usage({
    category: `Plugin-related commands`,
    description: `download a plugin`,
    details: `
      This command downloads the specified plugin from its remote location and updates the configuration to reference it in further CLI invocations.

      Three types of plugin references are accepted:

      - If the plugin is stored within the Yarn repository, it can be referenced by name.
      - Third-party plugins can be referenced directly through their public urls.
      - Local plugins can be referenced by their path on the disk.

      If the \`--no-checksum\` option is set, Yarn will no longer care if the plugin is modified.

      Plugins cannot be downloaded from the npm registry, and aren't allowed to have dependencies (they need to be bundled into a single file, possibly thanks to the \`@yarnpkg/builder\` package).
    `,
    examples: [[
            `Download and activate the "@yarnpkg/plugin-exec" plugin`,
            `$0 plugin import @yarnpkg/plugin-exec`,
        ], [
            `Download and activate the "@yarnpkg/plugin-exec" plugin (shorthand)`,
            `$0 plugin import exec`,
        ], [
            `Download and activate a community plugin`,
            `$0 plugin import https://example.org/path/to/plugin.js`,
        ], [
            `Activate a local plugin`,
            `$0 plugin import ./path/to/plugin.js`,
        ]],
});
exports.default = PluginImportCommand;
async function savePlugin(pluginSpec, pluginBuffer, { checksum = true, project, report }) {
    const { configuration } = project;
    const vmExports = {};
    const vmModule = { exports: vmExports };
    (0, vm_1.runInNewContext)(pluginBuffer.toString(), {
        module: vmModule,
        exports: vmExports,
    });
    const pluginName = vmModule.exports.name;
    const relativePath = `.yarn/plugins/${pluginName}.cjs`;
    const absolutePath = fslib_1.ppath.resolve(project.cwd, relativePath);
    report.reportInfo(core_1.MessageName.UNNAMED, `Saving the new plugin in ${core_2.formatUtils.pretty(configuration, relativePath, `magenta`)}`);
    await fslib_1.xfs.mkdirPromise(fslib_1.ppath.dirname(absolutePath), { recursive: true });
    await fslib_1.xfs.writeFilePromise(absolutePath, pluginBuffer);
    const pluginMeta = {
        path: relativePath,
        spec: pluginSpec,
    };
    if (checksum)
        pluginMeta.checksum = core_2.hashUtils.makeHash(pluginBuffer);
    await core_1.Configuration.addPlugin(project.cwd, [pluginMeta]);
}
exports.savePlugin = savePlugin;
