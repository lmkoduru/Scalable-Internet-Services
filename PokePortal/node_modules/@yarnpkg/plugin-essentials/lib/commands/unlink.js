"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const cli_1 = require("@yarnpkg/cli");
const core_1 = require("@yarnpkg/core");
const fslib_1 = require("@yarnpkg/fslib");
const clipanion_1 = require("clipanion");
const micromatch_1 = tslib_1.__importDefault(require("micromatch"));
// eslint-disable-next-line arca/no-default-export
class UnlinkCommand extends cli_1.BaseCommand {
    constructor() {
        super(...arguments);
        this.all = clipanion_1.Option.Boolean(`-A,--all`, false, {
            description: `Unlink all workspaces belonging to the target project from the current one`,
        });
        this.leadingArguments = clipanion_1.Option.Rest();
    }
    async execute() {
        const configuration = await core_1.Configuration.find(this.context.cwd, this.context.plugins);
        const { project, workspace } = await core_1.Project.find(configuration, this.context.cwd);
        const cache = await core_1.Cache.find(configuration);
        if (!workspace)
            throw new cli_1.WorkspaceRequiredError(project.cwd, this.context.cwd);
        const topLevelWorkspace = project.topLevelWorkspace;
        const workspacesToUnlink = new Set();
        if (this.leadingArguments.length === 0 && this.all) {
            for (const { pattern, reference } of topLevelWorkspace.manifest.resolutions) {
                if (reference.startsWith(`portal:`)) {
                    workspacesToUnlink.add(pattern.descriptor.fullName);
                }
            }
        }
        if (this.leadingArguments.length > 0) {
            for (const leadingArgument of this.leadingArguments) {
                const absoluteDestination = fslib_1.ppath.resolve(this.context.cwd, fslib_1.npath.toPortablePath(leadingArgument));
                if (core_1.miscUtils.isPathLike(leadingArgument)) {
                    const configuration2 = await core_1.Configuration.find(absoluteDestination, this.context.plugins, { useRc: false, strict: false });
                    const { project: project2, workspace: workspace2 } = await core_1.Project.find(configuration2, absoluteDestination);
                    if (!workspace2)
                        throw new cli_1.WorkspaceRequiredError(project2.cwd, absoluteDestination);
                    if (this.all) {
                        for (const workspace of project2.workspaces)
                            if (workspace.manifest.name)
                                workspacesToUnlink.add(core_1.structUtils.stringifyIdent(workspace.anchoredLocator));
                        if (workspacesToUnlink.size === 0) {
                            throw new clipanion_1.UsageError(`No workspace found to be unlinked in the target project`);
                        }
                    }
                    else {
                        if (!workspace2.manifest.name)
                            throw new clipanion_1.UsageError(`The target workspace doesn't have a name and thus cannot be unlinked`);
                        workspacesToUnlink.add(core_1.structUtils.stringifyIdent(workspace2.anchoredLocator));
                    }
                }
                else {
                    const fullNames = [...topLevelWorkspace.manifest.resolutions.map(({ pattern }) => pattern.descriptor.fullName)];
                    for (const fullName of (0, micromatch_1.default)(fullNames, leadingArgument)) {
                        workspacesToUnlink.add(fullName);
                    }
                }
            }
        }
        topLevelWorkspace.manifest.resolutions = topLevelWorkspace.manifest.resolutions.filter(({ pattern }) => {
            return !workspacesToUnlink.has(pattern.descriptor.fullName);
        });
        return await project.installWithNewReport({
            stdout: this.context.stdout,
            quiet: this.context.quiet,
        }, {
            cache,
        });
    }
}
UnlinkCommand.paths = [
    [`unlink`],
];
UnlinkCommand.usage = clipanion_1.Command.Usage({
    description: `disconnect the local project from another one`,
    details: `
      This command will remove any resolutions in the project-level manifest that would have been added via a yarn link with similar arguments.
    `,
    examples: [[
            `Unregister a remote workspace in the current project`,
            `$0 unlink ~/ts-loader`,
        ], [
            `Unregister all workspaces from a remote project in the current project`,
            `$0 unlink ~/jest --all`,
        ], [
            `Unregister all previously linked workspaces`,
            `$0 unlink --all`,
        ], [
            `Unregister all workspaces matching a glob`,
            `$0 unlink '@babel/*' 'pkg-{a,b}'`,
        ]],
});
exports.default = UnlinkCommand;
