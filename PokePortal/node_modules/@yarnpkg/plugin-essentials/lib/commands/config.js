"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const cli_1 = require("@yarnpkg/cli");
const core_1 = require("@yarnpkg/core");
const fslib_1 = require("@yarnpkg/fslib");
const clipanion_1 = require("clipanion");
const util_1 = require("util");
// eslint-disable-next-line arca/no-default-export
class ConfigCommand extends cli_1.BaseCommand {
    constructor() {
        super(...arguments);
        this.noDefaults = clipanion_1.Option.Boolean(`--no-defaults`, false, {
            description: `Omit the default values from the display`,
        });
        this.json = clipanion_1.Option.Boolean(`--json`, false, {
            description: `Format the output as an NDJSON stream`,
        });
        // Legacy flags; will emit errors or warnings when used
        this.verbose = clipanion_1.Option.Boolean(`-v,--verbose`, { hidden: true });
        this.why = clipanion_1.Option.Boolean(`--why`, { hidden: true });
        this.names = clipanion_1.Option.Rest();
    }
    async execute() {
        const configuration = await core_1.Configuration.find(this.context.cwd, this.context.plugins, {
            strict: false,
        });
        const deprecationExitCode = await (0, core_1.reportOptionDeprecations)({
            configuration,
            stdout: this.context.stdout,
            forceError: this.json,
        }, [{
                option: this.verbose,
                message: `The --verbose option is deprecated, the settings' descriptions are now always displayed`,
            }, {
                option: this.why,
                message: `The --why option is deprecated, the settings' sources are now always displayed`,
            }]);
        if (deprecationExitCode !== null)
            return deprecationExitCode;
        const names = this.names.length > 0
            ? [...new Set(this.names)].sort()
            : [...configuration.settings.keys()].sort();
        let trailingValue;
        const report = await core_1.StreamReport.start({
            configuration,
            json: this.json,
            stdout: this.context.stdout,
            includeFooter: false,
        }, async (report) => {
            if (configuration.invalid.size > 0 && !this.json) {
                for (const [key, source] of configuration.invalid)
                    report.reportError(core_1.MessageName.INVALID_CONFIGURATION_KEY, `Invalid configuration key "${key}" in ${source}`);
                report.reportSeparator();
            }
            if (this.json) {
                for (const name of names) {
                    const data = configuration.settings.get(name);
                    if (typeof data === `undefined`)
                        report.reportError(core_1.MessageName.INVALID_CONFIGURATION_KEY, `No configuration key named "${name}"`);
                    const effective = configuration.getSpecial(name, {
                        hideSecrets: true,
                        getNativePaths: true,
                    });
                    const source = configuration.sources.get(name) ?? `<default>`;
                    const sourceAsNativePath = source && source[0] !== `<`
                        ? fslib_1.npath.fromPortablePath(source)
                        : source;
                    report.reportJson({ key: name, effective, source: sourceAsNativePath, ...data });
                }
            }
            else {
                const inspectConfig = {
                    breakLength: Infinity,
                    colors: configuration.get(`enableColors`),
                    maxArrayLength: 2,
                };
                const configTreeChildren = {};
                const configTree = { children: configTreeChildren };
                for (const name of names) {
                    if (this.noDefaults && !configuration.sources.has(name))
                        continue;
                    const setting = configuration.settings.get(name);
                    const source = configuration.sources.get(name) ?? `<default>`;
                    const value = configuration.getSpecial(name, { hideSecrets: true, getNativePaths: true });
                    const fields = {
                        Description: {
                            label: `Description`,
                            value: core_1.formatUtils.tuple(core_1.formatUtils.Type.MARKDOWN, { text: setting.description, format: this.cli.format(), paragraphs: false }),
                        },
                        Source: {
                            label: `Source`,
                            value: core_1.formatUtils.tuple(source[0] === `<` ? core_1.formatUtils.Type.CODE : core_1.formatUtils.Type.PATH, source),
                        },
                    };
                    configTreeChildren[name] = {
                        value: core_1.formatUtils.tuple(core_1.formatUtils.Type.CODE, name),
                        children: fields,
                    };
                    const setValueTo = (node, value) => {
                        for (const [key, subValue] of value) {
                            if (subValue instanceof Map) {
                                const subFields = {};
                                node[key] = { children: subFields };
                                setValueTo(subFields, subValue);
                            }
                            else {
                                node[key] = {
                                    label: key,
                                    value: core_1.formatUtils.tuple(core_1.formatUtils.Type.NO_HINT, (0, util_1.inspect)(subValue, inspectConfig)),
                                };
                            }
                        }
                    };
                    if (value instanceof Map) {
                        setValueTo(fields, value);
                    }
                    else {
                        fields.Value = {
                            label: `Value`,
                            value: core_1.formatUtils.tuple(core_1.formatUtils.Type.NO_HINT, (0, util_1.inspect)(value, inspectConfig)),
                        };
                    }
                }
                if (names.length !== 1)
                    trailingValue = undefined;
                core_1.treeUtils.emitTree(configTree, {
                    configuration,
                    json: this.json,
                    stdout: this.context.stdout,
                    separators: 2,
                });
            }
        });
        if (!this.json && typeof trailingValue !== `undefined`) {
            const name = names[0];
            const value = (0, util_1.inspect)(configuration.getSpecial(name, { hideSecrets: true, getNativePaths: true }), {
                colors: configuration.get(`enableColors`),
            });
            this.context.stdout.write(`\n`);
            this.context.stdout.write(`${value}\n`);
        }
        return report.exitCode();
    }
}
ConfigCommand.paths = [
    [`config`],
];
ConfigCommand.usage = clipanion_1.Command.Usage({
    description: `display the current configuration`,
    details: `
      This command prints the current active configuration settings.
    `,
    examples: [[
            `Print the active configuration settings`,
            `$0 config`,
        ]],
});
exports.default = ConfigCommand;
