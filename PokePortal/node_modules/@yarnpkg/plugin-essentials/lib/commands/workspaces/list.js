"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const cli_1 = require("@yarnpkg/cli");
const core_1 = require("@yarnpkg/core");
const plugin_git_1 = require("@yarnpkg/plugin-git");
const clipanion_1 = require("clipanion");
// eslint-disable-next-line arca/no-default-export
class WorkspacesListCommand extends cli_1.BaseCommand {
    constructor() {
        super(...arguments);
        this.since = clipanion_1.Option.String(`--since`, {
            description: `Only include workspaces that have been changed since the specified ref.`,
            tolerateBoolean: true,
        });
        this.recursive = clipanion_1.Option.Boolean(`-R,--recursive`, false, {
            description: `Find packages via dependencies/devDependencies instead of using the workspaces field`,
        });
        this.noPrivate = clipanion_1.Option.Boolean(`--no-private`, {
            description: `Exclude workspaces that have the private field set to true`,
        });
        this.verbose = clipanion_1.Option.Boolean(`-v,--verbose`, false, {
            description: `Also return the cross-dependencies between workspaces`,
        });
        this.json = clipanion_1.Option.Boolean(`--json`, false, {
            description: `Format the output as an NDJSON stream`,
        });
    }
    async execute() {
        const configuration = await core_1.Configuration.find(this.context.cwd, this.context.plugins);
        const { project } = await core_1.Project.find(configuration, this.context.cwd);
        const report = await core_1.StreamReport.start({
            configuration,
            json: this.json,
            stdout: this.context.stdout,
        }, async (report) => {
            const candidates = this.since
                ? await plugin_git_1.gitUtils.fetchChangedWorkspaces({ ref: this.since, project })
                : project.workspaces;
            const workspaces = new Set(candidates);
            if (this.recursive)
                for (const dependents of [...candidates].map(candidate => candidate.getRecursiveWorkspaceDependents()))
                    for (const dependent of dependents)
                        workspaces.add(dependent);
            for (const workspace of workspaces) {
                const { manifest } = workspace;
                if (manifest.private && this.noPrivate)
                    continue;
                let extra;
                if (this.verbose) {
                    const workspaceDependencies = new Set();
                    const mismatchedWorkspaceDependencies = new Set();
                    for (const dependencyType of core_1.Manifest.hardDependencies) {
                        for (const [identHash, descriptor] of manifest.getForScope(dependencyType)) {
                            const matchingWorkspace = project.tryWorkspaceByDescriptor(descriptor);
                            if (matchingWorkspace === null) {
                                if (project.workspacesByIdent.has(identHash)) {
                                    mismatchedWorkspaceDependencies.add(descriptor);
                                }
                            }
                            else {
                                workspaceDependencies.add(matchingWorkspace);
                            }
                        }
                    }
                    extra = {
                        workspaceDependencies: Array.from(workspaceDependencies).map(workspace => {
                            return workspace.relativeCwd;
                        }),
                        mismatchedWorkspaceDependencies: Array.from(mismatchedWorkspaceDependencies).map(descriptor => {
                            return core_1.structUtils.stringifyDescriptor(descriptor);
                        }),
                    };
                }
                report.reportInfo(null, `${workspace.relativeCwd}`);
                report.reportJson({
                    location: workspace.relativeCwd,
                    name: manifest.name
                        ? core_1.structUtils.stringifyIdent(manifest.name)
                        : null,
                    ...extra,
                });
            }
        });
        return report.exitCode();
    }
}
WorkspacesListCommand.paths = [
    [`workspaces`, `list`],
];
WorkspacesListCommand.usage = clipanion_1.Command.Usage({
    category: `Workspace-related commands`,
    description: `list all available workspaces`,
    details: `
      This command will print the list of all workspaces in the project.

      - If \`--since\` is set, Yarn will only list workspaces that have been modified since the specified ref. By default Yarn will use the refs specified by the \`changesetBaseRefs\` configuration option.

      - If \`-R,--recursive\` is set, Yarn will find workspaces to run the command on by recursively evaluating \`dependencies\` and \`devDependencies\` fields, instead of looking at the \`workspaces\` fields.

      - If \`--no-private\` is set, Yarn will not list any workspaces that have the \`private\` field set to \`true\`.

      - If both the \`-v,--verbose\` and \`--json\` options are set, Yarn will also return the cross-dependencies between each workspaces (useful when you wish to automatically generate Buck / Bazel rules).
    `,
});
exports.default = WorkspacesListCommand;
