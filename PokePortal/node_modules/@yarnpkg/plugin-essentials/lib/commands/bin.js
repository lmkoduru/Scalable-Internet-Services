"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const cli_1 = require("@yarnpkg/cli");
const core_1 = require("@yarnpkg/core");
const core_2 = require("@yarnpkg/core");
const clipanion_1 = require("clipanion");
// eslint-disable-next-line arca/no-default-export
class BinCommand extends cli_1.BaseCommand {
    constructor() {
        super(...arguments);
        this.verbose = clipanion_1.Option.Boolean(`-v,--verbose`, false, {
            description: `Print both the binary name and the locator of the package that provides the binary`,
        });
        this.json = clipanion_1.Option.Boolean(`--json`, false, {
            description: `Format the output as an NDJSON stream`,
        });
        this.name = clipanion_1.Option.String({ required: false });
    }
    async execute() {
        const configuration = await core_1.Configuration.find(this.context.cwd, this.context.plugins);
        const { project, locator } = await core_1.Project.find(configuration, this.context.cwd);
        await project.restoreInstallState();
        if (this.name) {
            const binaries = await core_2.scriptUtils.getPackageAccessibleBinaries(locator, { project });
            const binary = binaries.get(this.name);
            if (!binary)
                throw new clipanion_1.UsageError(`Couldn't find a binary named "${this.name}" for package "${core_2.structUtils.prettyLocator(configuration, locator)}"`);
            const [/*pkg*/ , binaryFile] = binary;
            this.context.stdout.write(`${binaryFile}\n`);
            return 0;
        }
        const report = await core_1.StreamReport.start({
            configuration,
            json: this.json,
            stdout: this.context.stdout,
        }, async (report) => {
            const binaries = await core_2.scriptUtils.getPackageAccessibleBinaries(locator, { project });
            const keys = Array.from(binaries.keys());
            const maxKeyLength = keys.reduce((max, key) => Math.max(max, key.length), 0);
            for (const [name, [pkg, binaryFile]] of binaries) {
                report.reportJson({
                    name,
                    source: core_2.structUtils.stringifyIdent(pkg),
                    path: binaryFile,
                });
            }
            if (this.verbose) {
                for (const [name, [pkg]] of binaries) {
                    report.reportInfo(null, `${name.padEnd(maxKeyLength, ` `)}   ${core_2.structUtils.prettyLocator(configuration, pkg)}`);
                }
            }
            else {
                for (const name of binaries.keys()) {
                    report.reportInfo(null, name);
                }
            }
        });
        return report.exitCode();
    }
}
BinCommand.paths = [
    [`bin`],
];
BinCommand.usage = clipanion_1.Command.Usage({
    description: `get the path to a binary script`,
    details: `
      When used without arguments, this command will print the list of all the binaries available in the current workspace. Adding the \`-v,--verbose\` flag will cause the output to contain both the binary name and the locator of the package that provides the binary.

      When an argument is specified, this command will just print the path to the binary on the standard output and exit. Note that the reported path may be stored within a zip archive.
    `,
    examples: [[
            `List all the available binaries`,
            `$0 bin`,
        ], [
            `Print the path to a specific binary`,
            `$0 bin eslint`,
        ]],
});
exports.default = BinCommand;
