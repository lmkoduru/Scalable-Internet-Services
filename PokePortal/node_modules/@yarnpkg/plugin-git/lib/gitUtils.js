"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fetchChangedWorkspaces = exports.fetchChangedFiles = exports.fetchBase = exports.fetchRoot = exports.clone = exports.resolveUrl = exports.lsRemote = exports.validateRepoUrl = exports.normalizeLocator = exports.splitRepoUrl = exports.isGitUrl = exports.TreeishProtocols = exports.normalizeRepoUrl = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@yarnpkg/core");
const fslib_1 = require("@yarnpkg/fslib");
const clipanion_1 = require("clipanion");
const git_url_parse_1 = tslib_1.__importDefault(require("git-url-parse"));
const capitalize_1 = tslib_1.__importDefault(require("lodash/capitalize"));
const querystring_1 = tslib_1.__importDefault(require("querystring"));
const semver_1 = tslib_1.__importDefault(require("semver"));
const normalizeRepoUrl_1 = require("./utils/normalizeRepoUrl");
Object.defineProperty(exports, "normalizeRepoUrl", { enumerable: true, get: function () { return normalizeRepoUrl_1.normalizeRepoUrl; } });
function makeGitEnvironment() {
    return {
        ...process.env,
        // An option passed to SSH by Git to prevent SSH from asking for data (which would cause installs to hang when the SSH keys are missing)
        GIT_SSH_COMMAND: process.env.GIT_SSH_COMMAND || `${process.env.GIT_SSH || `ssh`} -o BatchMode=yes`,
    };
}
const gitPatterns = [
    /^ssh:/,
    /^git(?:\+[^:]+)?:/,
    // `git+` is optional, `.git` is required
    /^(?:git\+)?https?:[^#]+\/[^#]+(?:\.git)(?:#.*)?$/,
    /^git@[^#]+\/[^#]+\.git(?:#.*)?$/,
    /^(?:github:|https:\/\/github\.com\/)?(?!\.{1,2}\/)([a-zA-Z._0-9-]+)\/(?!\.{1,2}(?:#|$))([a-zA-Z._0-9-]+?)(?:\.git)?(?:#.*)?$/,
    // GitHub `/tarball/` URLs
    /^https:\/\/github\.com\/(?!\.{1,2}\/)([a-zA-Z0-9._-]+)\/(?!\.{1,2}(?:#|$))([a-zA-Z0-9._-]+?)\/tarball\/(.+)?$/,
];
var TreeishProtocols;
(function (TreeishProtocols) {
    TreeishProtocols["Commit"] = "commit";
    TreeishProtocols["Head"] = "head";
    TreeishProtocols["Tag"] = "tag";
    TreeishProtocols["Semver"] = "semver";
})(TreeishProtocols || (exports.TreeishProtocols = TreeishProtocols = {}));
/**
 * Determines whether a given url is a valid github git url via regex
 */
function isGitUrl(url) {
    return url ? gitPatterns.some(pattern => !!url.match(pattern)) : false;
}
exports.isGitUrl = isGitUrl;
function splitRepoUrl(url) {
    url = (0, normalizeRepoUrl_1.normalizeRepoUrl)(url);
    const hashIndex = url.indexOf(`#`);
    if (hashIndex === -1) {
        return {
            repo: url,
            treeish: {
                protocol: TreeishProtocols.Head,
                request: `HEAD`,
            },
            extra: {},
        };
    }
    const repo = url.slice(0, hashIndex);
    const subsequent = url.slice(hashIndex + 1);
    // New-style: "#commit=abcdef&workspace=foobar"
    if (subsequent.match(/^[a-z]+=/)) {
        const extra = querystring_1.default.parse(subsequent);
        for (const [key, value] of Object.entries(extra))
            if (typeof value !== `string`)
                throw new Error(`Assertion failed: The ${key} parameter must be a literal string`);
        const requestedProtocol = Object.values(TreeishProtocols).find(protocol => {
            return Object.hasOwn(extra, protocol);
        });
        const [protocol, request] = typeof requestedProtocol !== `undefined`
            ? [requestedProtocol, extra[requestedProtocol]]
            : [TreeishProtocols.Head, `HEAD`];
        for (const key of Object.values(TreeishProtocols))
            delete extra[key];
        return {
            repo,
            treeish: { protocol, request },
            extra: extra,
        };
    }
    else {
        // Old-style: "#commit:abcdef" or "#abcdef"
        const colonIndex = subsequent.indexOf(`:`);
        const [protocol, request] = colonIndex === -1
            ? [null, subsequent]
            : [subsequent.slice(0, colonIndex), subsequent.slice(colonIndex + 1)];
        return {
            repo,
            treeish: { protocol, request },
            extra: {},
        };
    }
}
exports.splitRepoUrl = splitRepoUrl;
function normalizeLocator(locator) {
    return core_1.structUtils.makeLocator(locator, (0, normalizeRepoUrl_1.normalizeRepoUrl)(locator.reference));
}
exports.normalizeLocator = normalizeLocator;
function validateRepoUrl(url, { configuration }) {
    const normalizedRepoUrl = (0, normalizeRepoUrl_1.normalizeRepoUrl)(url, { git: true });
    const networkSettings = core_1.httpUtils.getNetworkSettings(`https://${(0, git_url_parse_1.default)(normalizedRepoUrl).resource}`, { configuration });
    if (!networkSettings.enableNetwork)
        throw new core_1.ReportError(core_1.MessageName.NETWORK_DISABLED, `Request to '${normalizedRepoUrl}' has been blocked because of your configuration settings`);
    return normalizedRepoUrl;
}
exports.validateRepoUrl = validateRepoUrl;
async function lsRemote(repo, configuration) {
    const normalizedRepoUrl = validateRepoUrl(repo, { configuration });
    const res = await git(`listing refs`, [`ls-remote`, normalizedRepoUrl], {
        cwd: configuration.startingCwd,
        env: makeGitEnvironment(),
    }, {
        configuration,
        normalizedRepoUrl,
    });
    const refs = new Map();
    const matcher = /^([a-f0-9]{40})\t([^\n]+)/gm;
    let match;
    while ((match = matcher.exec(res.stdout)) !== null)
        refs.set(match[2], match[1]);
    return refs;
}
exports.lsRemote = lsRemote;
async function resolveUrl(url, configuration) {
    const { repo, treeish: { protocol, request }, extra } = splitRepoUrl(url);
    const refs = await lsRemote(repo, configuration);
    const resolve = (protocol, request) => {
        switch (protocol) {
            case TreeishProtocols.Commit: {
                if (!request.match(/^[a-f0-9]{40}$/))
                    throw new Error(`Invalid commit hash`);
                return querystring_1.default.stringify({
                    ...extra,
                    commit: request,
                });
            }
            case TreeishProtocols.Head: {
                const head = refs.get(request === `HEAD` ? request : `refs/heads/${request}`);
                if (typeof head === `undefined`)
                    throw new Error(`Unknown head ("${request}")`);
                return querystring_1.default.stringify({
                    ...extra,
                    commit: head,
                });
            }
            case TreeishProtocols.Tag: {
                const tag = refs.get(`refs/tags/${request}`);
                if (typeof tag === `undefined`)
                    throw new Error(`Unknown tag ("${request}")`);
                return querystring_1.default.stringify({
                    ...extra,
                    commit: tag,
                });
            }
            case TreeishProtocols.Semver: {
                const validRange = core_1.semverUtils.validRange(request);
                if (!validRange)
                    throw new Error(`Invalid range ("${request}")`);
                const semverTags = new Map([...refs.entries()].filter(([ref]) => {
                    return ref.startsWith(`refs/tags/`);
                }).map(([ref, hash]) => {
                    return [semver_1.default.parse(ref.slice(10)), hash];
                }).filter((entry) => {
                    return entry[0] !== null;
                }));
                const bestVersion = semver_1.default.maxSatisfying([...semverTags.keys()], validRange);
                if (bestVersion === null)
                    throw new Error(`No matching range ("${request}")`);
                return querystring_1.default.stringify({
                    ...extra,
                    commit: semverTags.get(bestVersion),
                });
            }
            case null: {
                let result;
                if ((result = tryResolve(TreeishProtocols.Commit, request)) !== null)
                    return result;
                if ((result = tryResolve(TreeishProtocols.Tag, request)) !== null)
                    return result;
                if ((result = tryResolve(TreeishProtocols.Head, request)) !== null)
                    return result;
                if (request.match(/^[a-f0-9]+$/)) {
                    throw new Error(`Couldn't resolve "${request}" as either a commit, a tag, or a head - if a commit, use the 40-characters commit hash`);
                }
                else {
                    throw new Error(`Couldn't resolve "${request}" as either a commit, a tag, or a head`);
                }
            }
            default: {
                throw new Error(`Invalid Git resolution protocol ("${protocol}")`);
            }
        }
    };
    const tryResolve = (protocol, request) => {
        try {
            return resolve(protocol, request);
        }
        catch (err) {
            return null;
        }
    };
    return (0, normalizeRepoUrl_1.normalizeRepoUrl)(`${repo}#${resolve(protocol, request)}`);
}
exports.resolveUrl = resolveUrl;
async function clone(url, configuration) {
    return await configuration.getLimit(`cloneConcurrency`)(async () => {
        const { repo, treeish: { protocol, request } } = splitRepoUrl(url);
        if (protocol !== `commit`)
            throw new Error(`Invalid treeish protocol when cloning`);
        const normalizedRepoUrl = validateRepoUrl(repo, { configuration });
        const directory = await fslib_1.xfs.mktempPromise();
        const execOpts = { cwd: directory, env: makeGitEnvironment() };
        await git(`cloning the repository`, [`clone`, `-c core.autocrlf=false`, normalizedRepoUrl, fslib_1.npath.fromPortablePath(directory)], execOpts, { configuration, normalizedRepoUrl });
        await git(`switching branch`, [`checkout`, `${request}`], execOpts, { configuration, normalizedRepoUrl });
        return directory;
    });
}
exports.clone = clone;
async function fetchRoot(initialCwd) {
    // Note: We can't just use `git rev-parse --show-toplevel`, because on Windows
    // it may return long paths even when the cwd uses short paths, and we have no
    // way to detect it from Node (not even realpath).
    let cwd;
    let nextCwd = initialCwd;
    do {
        cwd = nextCwd;
        if (await fslib_1.xfs.existsPromise(fslib_1.ppath.join(cwd, `.git`)))
            return cwd;
        nextCwd = fslib_1.ppath.dirname(cwd);
    } while (nextCwd !== cwd);
    return null;
}
exports.fetchRoot = fetchRoot;
async function fetchBase(root, { baseRefs }) {
    if (baseRefs.length === 0)
        throw new clipanion_1.UsageError(`Can't run this command with zero base refs specified.`);
    const ancestorBases = [];
    for (const candidate of baseRefs) {
        const { code } = await core_1.execUtils.execvp(`git`, [`merge-base`, candidate, `HEAD`], { cwd: root });
        if (code === 0) {
            ancestorBases.push(candidate);
        }
    }
    if (ancestorBases.length === 0)
        throw new clipanion_1.UsageError(`No ancestor could be found between any of HEAD and ${baseRefs.join(`, `)}`);
    const { stdout: mergeBaseStdout } = await core_1.execUtils.execvp(`git`, [`merge-base`, `HEAD`, ...ancestorBases], { cwd: root, strict: true });
    const hash = mergeBaseStdout.trim();
    const { stdout: showStdout } = await core_1.execUtils.execvp(`git`, [`show`, `--quiet`, `--pretty=format:%s`, hash], { cwd: root, strict: true });
    const title = showStdout.trim();
    return { hash, title };
}
exports.fetchBase = fetchBase;
// Note: This returns all changed files from the git diff,
// which can include files not belonging to a workspace
async function fetchChangedFiles(root, { base, project }) {
    const ignorePattern = core_1.miscUtils.buildIgnorePattern(project.configuration.get(`changesetIgnorePatterns`));
    const { stdout: localStdout } = await core_1.execUtils.execvp(`git`, [`diff`, `--name-only`, `${base}`], { cwd: root, strict: true });
    const trackedFiles = localStdout.split(/\r\n|\r|\n/).filter(file => file.length > 0).map(file => fslib_1.ppath.resolve(root, fslib_1.npath.toPortablePath(file)));
    const { stdout: untrackedStdout } = await core_1.execUtils.execvp(`git`, [`ls-files`, `--others`, `--exclude-standard`], { cwd: root, strict: true });
    const untrackedFiles = untrackedStdout.split(/\r\n|\r|\n/).filter(file => file.length > 0).map(file => fslib_1.ppath.resolve(root, fslib_1.npath.toPortablePath(file)));
    const changedFiles = [...new Set([...trackedFiles, ...untrackedFiles].sort())];
    return ignorePattern
        ? changedFiles.filter(p => !fslib_1.ppath.relative(project.cwd, p).match(ignorePattern))
        : changedFiles;
}
exports.fetchChangedFiles = fetchChangedFiles;
// Note: yarn artifacts are excluded from workspace change detection
// as they can be modified by changes to any workspace manifest file.
async function fetchChangedWorkspaces({ ref, project }) {
    if (project.configuration.projectCwd === null)
        throw new clipanion_1.UsageError(`This command can only be run from within a Yarn project`);
    const ignoredPaths = [
        fslib_1.ppath.resolve(project.cwd, fslib_1.Filename.lockfile),
        fslib_1.ppath.resolve(project.cwd, project.configuration.get(`cacheFolder`)),
        fslib_1.ppath.resolve(project.cwd, project.configuration.get(`installStatePath`)),
        fslib_1.ppath.resolve(project.cwd, project.configuration.get(`virtualFolder`)),
    ];
    await project.configuration.triggerHook((hooks) => {
        return hooks.populateYarnPaths;
    }, project, (path) => {
        if (path != null) {
            ignoredPaths.push(path);
        }
    });
    const root = await fetchRoot(project.configuration.projectCwd);
    if (root == null)
        throw new clipanion_1.UsageError(`This command can only be run on Git repositories`);
    const base = await fetchBase(root, { baseRefs: typeof ref === `string` ? [ref] : project.configuration.get(`changesetBaseRefs`) });
    const changedFiles = await fetchChangedFiles(root, { base: base.hash, project });
    return new Set(core_1.miscUtils.mapAndFilter(changedFiles, file => {
        const workspace = project.tryWorkspaceByFilePath(file);
        if (workspace === null)
            return core_1.miscUtils.mapAndFilter.skip;
        if (ignoredPaths.some(ignoredPath => file.startsWith(ignoredPath)))
            return core_1.miscUtils.mapAndFilter.skip;
        return workspace;
    }));
}
exports.fetchChangedWorkspaces = fetchChangedWorkspaces;
async function git(message, args, opts, { configuration, normalizedRepoUrl }) {
    try {
        return await core_1.execUtils.execvp(`git`, args, {
            ...opts,
            // The promise won't reject on non-zero exit codes unless we pass the strict option.
            strict: true,
        });
    }
    catch (error) {
        if (!(error instanceof core_1.execUtils.ExecError))
            throw error;
        const execErrorReportExtra = error.reportExtra;
        const stderr = error.stderr.toString();
        throw new core_1.ReportError(core_1.MessageName.EXCEPTION, `Failed ${message}`, report => {
            report.reportError(core_1.MessageName.EXCEPTION, `  ${core_1.formatUtils.prettyField(configuration, {
                label: `Repository URL`,
                value: core_1.formatUtils.tuple(core_1.formatUtils.Type.URL, normalizedRepoUrl),
            })}`);
            for (const match of stderr.matchAll(/^(.+?): (.*)$/gm)) {
                let [, errorName, errorMessage] = match;
                errorName = errorName.toLowerCase();
                const label = errorName === `error`
                    ? `Error`
                    : `${(0, capitalize_1.default)(errorName)} Error`;
                report.reportError(core_1.MessageName.EXCEPTION, `  ${core_1.formatUtils.prettyField(configuration, {
                    label,
                    value: core_1.formatUtils.tuple(core_1.formatUtils.Type.NO_HINT, errorMessage),
                })}`);
            }
            execErrorReportExtra?.(report);
        });
    }
}
